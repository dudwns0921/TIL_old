# var VS let, const

자바스크립트에서는 var, let, const 총 3가지의 키워드로 변수 선언이 가능하다.

ES6에서 let과 const가 추가되었는데, 그 이유는 var가 갖고 있는 문제점들 때문이다.

## var

- **변수 중복 선언 가능하며, 예기치 못한 값을 반환할 수 있다.**

```javascript
var x= 1;
var x= 100;

console.log(x); // 100
```

만약 큰 규모의 애플리케이션을 만들 때 여러 개발자들이 같은 이름의 변수를 var로 선언하게 된다면

마지막으로 해당 변수를 선언한 사람을 제외한 모든 사람들은 원하지 않는 값을 반환받게 될 것이다.

- **함수 레벨 스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수가 된다.**

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인식한다.

스코프는 유효 범위라는 뜻으로 var 키워드로 선언된 변수는 함수 코드 블록에 들어있을 때는 외부에서 접근할 수 없다는 뜻이다.

```javascript
function scope() {
    var x=1;
}
console.log(x); //x is not defined
```

하지만 함수 코드 블록만을 지역 스코프로 인정한다는 말은 그 외의 블록들에서 선언된 변수는 전역 변수가 된다는 의미이다.

```javascript
var x=1;

if(true) {
    var x=10;
}
console.log(x); // 10
```

함수 레벨 스코프는 전역 변수를 남발할 가능성을 높인다.

이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다.

- **변수 선언문 이전에 변수를 참조하면 언제나 undefined를 반환한다.**

var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.

즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.

단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다. 아래 예시를 참조해보자.

```javascript
console.log(x); // undefined

x= 1;

console.log(x); // 1

var x;
```

맨 밑의 변수 선언문이 호이스팅에 의해 맨 위로 끌어올려지고, 어떠한 값도 할당되어있지 않기 때문에 undefined를 출력한다.

그 이후에 값이 할당되고, 그 값이 출력되는 걸 확인할 수 있다.

변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않는다.

다만 프로그램의 흐름상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.

## let

위의 문제점들이 let에서는 어떻게 해결됐을지 살펴보자.

- **변수 중복 선언 금지**

- **블록 레벨 스코프**

let 키워드로 선언한 변수는 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```javascript
let x=1;

{
    let x=2;
    let y=3;
}

console.log(x); // 1
console.log(y); // undefined
```

- **변수 호이스팅이 발생하지 않는 것처럼 동작한다.**

자바스크립트에서 변수 선언은 `선언 → 초기화` 단계를 거쳐 수행된다.

- **선언 단계**: 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
- **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

var 키워드로 선언한 변수는 위 2단계가 동시에 진행된다.

그래서 위에서 살펴본 예시처럼 선언문 이전에 변수를 참조할 수 있는 것이다.

이와 달리 let 키워드로 선언한 변수는 두 단계가 분리되어 진행된다.

런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 진행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.

만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다.

let 키워드로 선언한 변수는 스코프의 시작 지점부터 변수 선언문까지 변수를 참조할 수 없다.

이 구간을 **일시적 사각지대(Temporal Dead Zone, TDZ)** 라고 한다.

결국 let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 보이지만, 그렇지 않다.

```javascript
let x=1; // 전역변수

{
    console.log(x); // Uncaught ReferenceError: Cannot access 'x' before initialization
    let x=2; // 지역변수
}
```

호이스팅이 일어나지 않는다면 위 예제는 전역 변수 x의 값인 1을 출력해야 한다.

하지만 let으로 변수를 선언해도 여전히 호이스팅이 발생하기 때문에 참조 에러가 발생한다.

## const

const 키워드는 상수를 선언하기 위해 사용한다.

const의 특징은 let 키워드와 거의 동일해 const으로도 var의 문제점에서 벗어날 수 있다.

다만 let과 몇 가지 다른 점들이 있어 그들을 중심으로 살펴보자.

- **const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.**

```javascript
const x; // Uncaught SyntaxError: Missing initializer in const declaration
```

그렇지 않으면 위와 같이 문법 에러가 발생한다.

- **재할당 금지**

var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.

- **const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다.**

const 키워드로 선언된 변수에 원시 값을 할당한 경우 값을 변경할 수 없지만 객체를 할당한 경우 값을 변경할 수 있다.

```javascript
const person ={
    name: "Jun"
}

person.name="Lee";

console.log(person); // {name:"Lee"}
```

## 결론

- **var보다는 let과 const를 사용하자.**

조금 냉정하게 보자면 var의 미래는 없다고 볼 수 있다.

지금까지 var가 유지되는 이유는 갑자기 var가 수정된다면 오류가 생기는 웹페이지들이 너무나 많기 때문이다.

그렇기 때문에 var을 유지한 채로 let과 const를 만든 것이지, var가 유용해서 유지하고 있는 것이 아니다.

- **재할당이 필요한 경우에 한정해 let 키워드를 사용하자.**
- **변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const 키워드를 사용한다.**

사실 변수를 선언하는 시점에서는 재할당이 필요할지 모르는 경우가 많다.

그러니까 변수를 선언할 때는 일단 const를 사용하는 마인드를 가지자.

재할당이 필요하다면 나중에 변경해도 결코 늦지 않다.

# :books:참고자료

이웅모, 모던 자바스크립트 Deep Dive, 위키북스, 2020

노마드코더 수업 내용