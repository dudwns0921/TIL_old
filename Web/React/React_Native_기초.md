우리가 react 코드를 작성하고 리액트JS는 이를 평범한 자바스크립트로 변환시켜준 후 브라우저가 실행시켜준다.

그래서 어떤 사람들은 리액트 네이티브가 앱 안의 브라우저와 같다고 생각하는 경우가 있다.



react Native는 브라우저가 아니다.

리액트 네이티브는 아름다운 번역기

인터페이스 우리와 운영체제 사이에 있는 것이다.

우리가 코드를 작성하면 그 코드는 리액트 네이티브를 통해 IOS 또는 JAVA 안드로이드 코드로 번역이 된다.



리액트 네이티브를 이용해서 버튼을 만든다

리액트 네이티브는 ios / 안드로이드에게 버튼을 그려달라고 요청한다.

둘은 그 모습이 다를 수밖에 없는데,

리액트 네이티브는 요청을 할 뿐 실제로 버튼은 만드는 건 운영체제인 ios와 안드로이드이기 때문이다.

따라서 ios 버튼, 안드로이드 버튼이 만들어지는 것이다.



리액트 네이티브에는 브라우저가 없고 브릿지라는 것이 있다.

우리가 해야하는 건 리액트 네이티브 코드만 만들면 리액트 네이티브는 알아서 브릿지를 통해 ios와 안드로이드에게 말을 해줄 것이다.



사용자의 이벤트 -> ios, 안드로이드에서 수집

화면의 어디에서 event가 발생했는지, 얼마나 눌렸는지 등등



브릿지를 통해 그 정보를 받은 리액트 네이티브는 json 메시지를 생성

가령 버튼이 3초동안 눌렸습니다



우리가 작성하는 부분인 자바스크립트는 리액트 네이티브에서 보낸 메시지를 받는다



이벤트에 대한 코드가 실행되고 다시 네이티브에 메시지를 전송한다

가령 버튼이 3초 동안 눌리면 화면의 색을 빨강색으로 변경한다.



리액트 네이티브는 이 메시지를 다시 운영체제 쪽으로 전달한다.

그리고 운영체제에서 이 메시지를 기반하여 실행한다.



자바스크립트는 우리 개발자들이 메시지를 주고 받기 위해 쓰는 레이어에 불과하다.



자바스크립트 부분을 제외한 모든 인프라를 갖추기 위해서는 JAVA, 시뮬레이터, 안드로이드 스튜디오, Xcode 등이 필요하다.

앱을 만들고 앱스토어에 이를 내보낼 때 자바스크립트 코드를 포함한 인프라 전부를 함께 내보내는 것이다. 





따라서 expo go 라는 애플리케이션을 통해 이 모든 인프라 설치를 건너뛰고 자바스크립트 부분에만 작성을 할 것이다.

expo go는 자바스크립트 부분을 제외한 모든 기반 시설을 만들어서 앱 스토어에 보낸 것이다.

또한 우리가 자바스크립트 코드를 변경할 수 있도록 해준다.

컴퓨터에서 폰으로 바로 코드를 보낼 수 잇도록 해준다.

컴파일 과정을 건너뛸 수 있도록 해준다.

expo는 우리가 만들고 싶지 않은 인프라 시설을 미리 만들어둔 애플리케이션이고, 자바스크립트 코드를 변경할 수 있도록 해준다.



expo go를 실행시키기 위해서는 컴퓨터와 휴대폰 모두에서 expo 로그인을 해주어야 한다.

그 다음 npm run start를 실행하면 휴대폰에서 해당 프로젝트의 화면을 확인할 수 있다. 



___



초기에 react native에서는 사용자들에게 최대한 많은 양의 컴포넌트를 제공하고 싶어했다.

유지관리와 업데이트가 어려웠음



하지만 그렇게 하는 것이 어렵고 엄청 많은 버그가 있다는 걸 깨달았다.

제공했던 APIs 컴포넌트들을 줄였다.



그래서 가장 중요한 기능만을 남기고 규모를 줄였다.



컴포넌트는 화면에 렌더링할 항목들



API는 자바스크립트 코드

운영체제와 소통



컴포넌트와 API를 통해 폰과 앱이 작동하는 방식을 변경할 수 있다.



컴포넌트와 API의 규모가 줄어들고, 사람들이 많이 쓰는 것들은 커뮤니티에 의존하기 시작

EXpo팀은 몇몇 컴포넌트나 API가 중요하다고 생각했고 자체적으로 만들기 시작

이걸 Expo SDK라고 한다.



그래서 React Native Packages, APIs에서 원하는 걸 찾을 수 없다면

Expo를 사용하면됨



Expo는 더 나아가 React Native에서 제공하는 컴포넌트들을 좀 더 개선해서 제공하기로 함

그래서 expo 프로젝트에 status 바가 두 개 있는 것임



___





모바일에서는 오직 flexbox만 사용



view에게 display : flex를 선언해줄 필요가 없다.

기본적으로 모든 view는 flexbox이다.

기본값으로 column이다.



스크린에 따라 보이는 크기가 다 달라지므로 우리는 px 에 의존하여 컴포넌트들을 만들지 않을 것이다.

반응형으로 만들 예정

레이아웃에서는 사용하지 않을 예정





```
    <View style={{ flex : 1}}>
      <View style={{flex:1, backgroundColor:"tomato"}}></View>
      <View style={{flex:2, backgroundColor:"teal"}}></View>
      <View style={{flex:1, backgroundColor:"orange"}}></View>
    </View>
```



우리는 비율로 레이아웃을 만들 것이다.

부모 container에 flex : 1을 지정해주고, 자식 view들에게 각각 비율들을 선언하며ㅑㄴ 된다.

다른 view와 비율을 따지는 것이기 때문에 전체적으로 봤을 때는 부모 view 하나만 존재한다.

따라서 부모 view에 어떤 값을 넣든 상관이 없다.



view에 css 적용 방법

```react
const styles = StyleSheet.create({

 container:{

  flex : 1, backgroundColor : "skyblue"

 }

})

<View style={styles.container}></View>


```





scrollview에는 style prop이 존재하지 않는다

따라서 contentContainerStyle로 바꿔준다.



스크롤뷰에는 크기를 줄 필요가 없다

스크롤뷰는 당연히 스크린보다 커야한다



Dimension은 화면 크기를 알려주는 api이다.



pagingEnabled

각 스크린마다 멈추도록 스크린을 조정한다.





showsHorizontalScrollIndicator={false}

밑에 어느 페이지인지 알려주는 indicator를 없앤다.



import * as Location from 'expo-location'; 

Location.requestForegroundPermissionsAsync();

콘솔에서 반환한 객체를 살펴보면

유저가 위치 정보를 확인하는 것을 허용헀는지를 알려주는 granted 가 있다.

true면 허용, false면 허용 안함









