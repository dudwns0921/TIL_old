# 운영체제

## 프로세스 스케줄링

### 프로세스 스케줄링

#### 스케줄링

- 스케줄링
  - 여러 가지 작업의 처리순서를 결정하는 것
  - 프로세스 스케줄링, 디스크 스케줄링
- 프로세스 스케줄링
  - 주어진 프로세스가 여러 개인 경우, 프로세스 처리순서를 결정하는 것

#### 스케줄링 단계

- 작업 작업 큐 삽입

- 상위단계 스케줄링
  - 작업 요청이 들어왔을 때 해당 작업을 프로세스로 만드는 과정
  - 시스템의 자원을 효율적으로 이용할 수 있도록 함
  - 요청이 들어온 작업들이 시스템의 자원을 효율적으로 이용할 수 있도록 함
- 하위 단계 스케줄링
  - 준비 큐에 있는 프로세스를 선택하여 사용 가능한 CPU 할당(디스패치)하는 역할
  - 수행 주체 : 디스패처
  - 활성화된 작업들은 준비큐에서 CPU 할당 대기
  - 어떤 작업들에 CPU를 할당할지 결정하는 것을 하위 단계 스케줄링
- 중간 단계 스케줄링
  - 시스템에 대한 단기적인 부하를 조절하도록 하는 스케줄
  - 시스템에 CPU 작업이 너무 몰려있다면 프로세스들에서 CPU 강제 회수 등의 작업을 수행

#### 스케줄링의 목표

- 스케줄링 기본 목표
  - 공정성
    - 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함
  - 균형
    - 시스템 자원이 충분히 활용될 수 있게 함
- 운영체제의 유형에 따른 스케줄링의 목표
  - 일괄처리 운영체제
    - 처리량의 극대화
      - 주어진 시간에 처리한 프로세스 수
    - 반환시간의 최소화
      - 프로세스 생성 시점부터 종료 시점까지의 소요시간
    - CPU 활용의 극대화
  - 시분할 운영체제
    - 빠른 응답시간
      - 요청한 시점부터 반응이 시작되는 시점까지의 소요시간
    - 과다한 대기시간 방지
      - 프로세스가 종료될 때까지 준비 큐에서 기다린 시간의 
    - 시분할 운영체제는 시간을 쪼개 여러 사용자들이 각자 혼자서 시스템을 쓰는 것처럼 만들기 위해 빠른 응답시간을 목표로 둠
  - 실시간 운영체제
    - 처리기한 맞춤

모든 스케줄링의 목표를 달성할 수는 없음

- 스케줄링의 목표에 따라 우선적으로 고려해야 할 기본적인 정책
  - 선점 스케줄링 정책
    - 실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식
    - 높은 우선순위의 프로세스를 우선 처리해야 하는 경우에 유용
      - 실시간 시스템
      - 시분할 시스템
    - 문맥 교환에 따른 오버헤드 발생
      - 문맥
        - CPU의 모든 레지스터와 기타 운영체제에 따라 요구되는 프로세스의 상태
      - 문맥 교환
        - CPU가 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업
        - 프로세스 A 동작에 필요한 여러 레지스터 정보들이 CPU에 저장되어있음
        - CPU의 레지스터 정보들을 프로세스 A의 PCB에 임시보관
        - 새롭게 CPU를 사용하게 될 프로세스 PCB의 정보들이 CPU의 레지스터에 저장됨
        - 프로세스 B를 실행할 수 있는 준비가 됨
        - 이런 식의 작업은 오버헤드가 발생하기 때문에 문맥 교환이 빠르게 실행되도록 만들어져야 함
  - 비선점 스케줄링 정책
    - 실행 중인 프로세스를 바로 준비상태로 전이시킬 수 없는 스케줄링 방식
      - CPU를 강제로 회수할 수 없음
      - 실행에서 준비로 상태전이가 불가
      - 종료나 대기로 상태 변경이 가능
    - CPU를 할당받아 실행이 시작된 프로세스는 대기상태나 종료상태로 전이될 때까지 계속 실행상태에 있게 됨
    - 강제적인 문맥 교환이 없어 오버헤드 발생하지 않음
      - 자발적인 문맥 교환은 있음
    - 긴 프로세스 실행 중이라면 짧은 프로세스가 오래 기다리게 되는 경우 발생

#### 스케줄링의 평가 기준

- 평균대기시간
  - 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간 합의 평균값
- 평균반환시간
  - 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균

### 스케줄링 알고리즘

#### FCFS 스케줄링

- FCFS(First-Come First-Served)
- 비선점 방식
- 준비 큐에 도착한 순서에 따라 디스패치
- 장점
  - 가장 간단한 스케줄링 기법
- 단점
  - 짧은 프로세스가 긴 프로세스를 기다리거나 중요 프로세스가 나중에 수행될 수도 있음
    - 시분할 운영체제나 실시간 운영체제에는 부적합
  - 프로세스들의 도착순서에 따라 평균반환시간이 크게 변함
    - 예측이 어렵다는 의미

#### SJF 스케줄링

- Shortest Job First
- 비선점 방식
- 준비 큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치
- 장점
  - 일괄처리 환경에서 구현하기 쉬움
- 단점
  - 실제로는 먼저 처리할 프로세스의 CPU 시간을 예상할 수 없음
  - 새로 들어온 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 실행될 수도 있음
    - 시분할 운영체제나 실시간 운영체제에는 부적합
  - 가령 긴 프로세스 이후에 짧은 프로세스가 계속 준비큐에 들어오면 긴 프로세스는 순서가 계속 뒤로 밀릴 수밖에 없다

#### SRT 스케줄링

- Shortest Remaining Time
- SJF 알고리즘의 선점 방식
- 준비 큐에서 기다리는 프로세스중 남은 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치

- 장점
  - SJF보다 평균대기시간이나 평균반환시간에서 효율적
- 단점
  - 실제로는 프로세스의 CPU 시간을 예상할 수 없음
  - 각 프로세스의 실행시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버헤드가 큼

#### RR 스케줄링

- 선점 방식
- 준비 큐에 도착한 순서대로 디스패치하지만 정해진 시간 할당량에 의해 실행 제한
- 시간 할당량 안에 종료하지 못한 프로세스는 준비 큐의 마지막에 배치
