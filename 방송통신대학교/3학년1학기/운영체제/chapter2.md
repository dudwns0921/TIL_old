# 운영체제

#### 프로세스의 구성

- 메모리 구조
  - 프로그램 실행에 직접적으로 필요한 코드와 데이터
  - 코드 영역
  - 데이터 영역
    - 상수나 변수의 값
    - 서브프로그램 호출 상태 등
    - 정적 데이터 영역
      - 프로그램 시작부터 끝까지 관리되어야 하는 변수들
    - 스택 영역
      - 서브프로그램 호출
      - 지역 변수 사용 등
    - 힙 영역
      - 동적 변수들 중 사용자가 수동으로 할당하는 것
- 포르세스 제어 블록(Process Control Block)
  - 운영체제가 프로세스를 관리하기 위한 필요한 정보
    - 프로세스 번호
      - 구분자의 역할
    - 프로세스 상태
      - 동작, 대기, 준비 등 프로세스의 상태를 나타냄
    - 프로그램 카운터
      - CPU가 사용하는 레지스터중 하나
      - 현재 실행중인 명령어 다음 명령어의 위치값
    - 레지스터
      - 레지스터를 저장할 수 있는 공간
      - CPU에 다 저장하면 되는데 왜 레지스터가 필요할까?
      - 어떤 프로세스가 작업하다 작업이 완료되지 않았을 때 CPU를 다른 프로세스에 넘겨줘야 하는 경우가 있음
      - CPU를 다시 할당받았을 때 레지스터를 모두 복구시키는 것
    - 메모리 관리 정보
      - 가상 메모리 매핑 정보들
    - 프로세스 우선순위
    - 회계 정보
  - 각 프로세스마다 존재
  - 여러 프로세스가 번갈아 실행되는 경우 PCB에 저장된 정보 활용

#### 프로세스 상태 관리

- 프로세스 상태
  - 생성
    - 처음 작업이 시스템에 주어진 상태
    - 제일 먼저 PCB를 생성
    - PID 할당, 상태 정보 저장 등
    - 메모리 공간을 할당받아야 함
  - 준비
    - 실행 준비가 되어 CPU 할당을 기다리는 상태
    - 메모리 할당 받은 상태
    - 준비 Queue에 들어와있는 상태
  - 실행
    - 프로세스가 처리되는 상태
    - CPU를 할당받고 프로그램의 명령어를 처리함
  - 종료
    - 프로세스가 더 이상 실행되지 않도록 끝난 상태
  - 대기
    - 프로세스가 I/O 작업이 끝날 때까지 또는 특정 자원을 할당받을 때까지 보류되는 상태
    - 입출력 작업 등으로 CPU를 사용하지 않을 때, 계속 CPU를 사용하기 보다는 대기 상태로 전환하는 것이 운영체제 입장에서는 훨씬 효율적이다.
    - 다른 프로세스에게 CPU를 할당해줌

- 프로세스 상태 변화
  - 생성에서는 준비로만 변화가 가능
  - CPU를 할당받게 되면 디스패치(특정 프로세스에  CPU를 할당해주는 것)를 통해 실행으로 변화가 가능
  - 실행에서 할당시간 만료가 될 경우 실행에서 준비로 되돌아갈 수 있음
  - 입출력, 페이지 변환 같은 이벤트가 생겼을 때, 이벤트 대기를 통해 대기 상태로 변함
  - 다시 실행할 수 있는 상태, 재개 조건 만족을 하게 되면 대기에서 다시 준비 상태로 변함
  - 그리고 다시 디스패치를 통해 실행 상태로 변함
  - 더 이상 실행할 것들이 없다면 종료 상태로 변함
  - 치명적인 오류로 인해 갑자기 종료 상태로 변할 수 있음
  - 부모 프로세스가 자식 프로세스를 강제적으로 변경할 수 있음
  - 각 상태 사이의 관계를 잘 기억할 것

#### 부모 프로세스와 자식 프로세스

- 프로세스 생성 방법
  - 사용자가 프로그램을 직접 실행
  - 한 프로세스가 다른 프로세스를 생성
    - 프로세스 생성 시스템 호출 이용
    - 커널 모드로 변경할 때 사용하는 것이 시스템 호출
    - 운영체제가 새로운 프로세스를 만들어야 한다고 인식하고 새로운 프로세스를 생성
    - 부모 프로세스
      - 시스템 호출을 하는 프로세스
    - 자식 프로세스
      - 시스템 호출을 통해 새로 생성된 프로세스

#### 프로세스 생성 시스템 호출

- UNIX, Linux : fork()
  - 자식 프로세스는 부모 프로세스의 복제본
  - PID를 제외하고는 완전히 똑같다.
  - fork()를 했을 때 부모 프로세스에서는 자식 프로세스의 PID를 반환하지만, 자식 프로세스에서는 0을 반환
  - 이를 통해 부모 프로세스인지 자식 프로세스인지 확인이 가능
- UNIX, Linux : exec()
  - 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행하게 할 경우
  - prg2이라는 새로운 프로그램을 실행하도록 되어있을 경우
  - 코드, 데이터 영역, PCB 모두 prg2로 변환
  - PID는 유지함

- Windows : CreateProcess()
  - 자식 프로세스는 새로운 프로그램으로 생성
  - UNIX, Linux와 달리 처음부터 복제본이 아닌 새로운 프로그램으로 생성
- 프로세스 종료 방법
  - 프로세스가 모든 처리를 완료(정상적 종료)
  - 부모 프로세스에 의해 자식 프로세스가 강제 종료
    - 프로세스 종료 시스템 호출 이용
    - 자식 프로세스 생성시 얻은 자식 PID 이용
  - 부모 프로세스가 종료되는 경우 운영체제가 자식 프로세스 종료

### 쓰레드

#### 전통적인 프로세스

- 하나의 프로그램을 실행하기 위한 기본적인 단위
- 자원 소유의 단위
  - 하나의 메모리 구조
- 디스패칭의 단위
  - 하나의 제어흐름
- 프로세스 내에서 다중처리 불가능

#### 쓰레드

- 프로세스 내에서 다중처리를 위해 제안된 개념
- 하나의 프로그램을 실행하기 위한 기본적인 단위
  - 기본적인 단위를 프로세스에서 쓰레드로 한 단계 낮추었다고 생각하면 됨
- 디스패칭의 단위
  - CPU 할당받아 명령어를 처리하는 것
  - 쓰레드별로 디스패칭을 해야하기 때문에 PC값을 쓰레드별로 갖고 있음
  - 자원 소유의 단위는 여전히 프로세스
  - 디스패칭은 쓰레드별로 하기 때문에 디스패칭의 단위만 쓰레드로 변경됨
- 하나의 프로세스 안에는 여러 개의 쓰레드가 존재
- 쓰레드는 실행에 필요한 최소한의 정보만 가짐
  - PC를 포함한 레지스터 값
  - 상태 정보
  - 스택 영역
  - 공통되게 쓸 수 있는 건 프로세스에 두고서 자원 소유의 단위로 활용
- 멀티 CPU 또는 멀티코어 컴퓨터 시스템
  - 다중 쓰레드를 병렬로 처리 가능

- 처리속도별로 쓰레드가 나눠진 경우
  - 효율적인 처리가 가능
