# 알고리즘

## 3강. 분할정복 알고리즘 (1)

### 분할정복 방법의 원리

- 순환적으로 문제를 푸는 하향식 접근 방법
  - 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고,
  - 피자 먹는 걸 생각해보기
  - 이렇게 분할된 작은 문제들을 각각 해결한 후 이 해들을 결합해서 원래 문제의 해를 구하는 방식
- 특징
  - 분할된 작은 문제는 원래 문제와 동일
    - 단, 입력 크기만 작아짐
  - 분할된 작은 문제는 서로 독립적
    - 순환적 분할 및 결과 통합이 가능
- 분할 정복 알고리즘은 순환 알고리즘으로 표현
- 순환 알고리즘의 성능은 점화식으로 표현
- 이 점화식을 풀어서 성능을 표현

#### 분할정복 방법의 처리 단계

- 각 순환 호출마다 세 단계의 처리 과정을 거침
  - 분할
    - 주어진 문제를 여러 개의 작은 문제로 분할
  - 정복
    - 작은 문제를 순환적으로 분할
    - 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구한다.
  - 결합
    - 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다.

#### 적용 알고리즘의 종류 및 분할 과정

- 이진 탐색
- 퀵 정렬
- 합병 정렬
- 선택 문제

### 이진 탐색

- 정렬된 상태의 입력 데이터에 대한 효과적인 탐색 방법
  - 오름차순으로 정렬되었다고 가정
- 분할
  - 배열의 가운데 원소를 기준으로 왼쪽과 오른쪽 부분배열로 분할
  - 탐색키와 가운데 원소가 같으면 가운데 원소의 배열 인덱스를 반환/종료

- 정복
  - 탐색키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출
  - 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환 호출

- 결합
  - 필요 없음(부분배열에 대해서 탐색 결과가 직접 반환)

- 입력 크기 n일 때 최대 분할 횟수, 최대 비교 횟수
  - 데이터가 2로 나누다가 1이 되면 한계 지점
  - 최대 비교 횟수는 최대 분할 횟수 +1

- T(n) = 입력 크기 n에 대한 탐색 과정에서의 모든 비교 횟수의 합
  - 맨 바깥 수준에서의 비교 횟수 + 순환 호출에서의 비교 횟수
  - T(n) = T(n/2) + O(1), T(1)=c1
  - 가운데를 찾을 때에는 데이터 수에 상관없이 일정한 시간(상수 시간)이 걸림

- 입력 배열의 데이터가 정렬된 경우에 대해서만 적용 가능
- 삽입 / 삭제 연산은 부가적인 데이터 이동을 수반
  - 데이터 정렬 상태 유지를 위해서 평균 n/2개의 데이터 이동이 발생
  - 삽입 / 삭제가 빈번한 응용에서는 부적합


### 퀵 정렬

- 특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
  - 오름차순으로 정렬한다고 가정
- 피벗
  - 주어진 배열을 두 부분배열로 분할할 때 기준이 되는 특정 원소
    - 보통 주어진 배열의 첫 번째 원소로 지정

#### 개념과 원리

- 피벗이 제자리를 잡도록 하여 정렬하는 방식
- 왼쪽 부분배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값
- 분할
  - 피벗을 기준으로 주어진 배열을 두 부분배열로 분할
  - 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다
  - 필요없음
- 왼쪽부터 수행
- 첫 번째 원소를 피벗으로 설정
- 왼쪽 맨 끝 인덱스를 1로(Left), 마지막 인덱스를 n-1로 설정(Right)
- Left는 피벗보다 큰 값을 찾으며 증가
- Right는 피벗보다 작은 값을 찾으며 감소
- Left와 Right를 교체
- Left가 Right보다 커지면 피벗과 Right의 위치를 바꾸고 종료
- 일반적으로 오른쪽 맨 끝에는 무한대가 있다고 가정

#### 성능 분석

- 분할 함수 수행 시간
  - 피벗과의 비교 횟수
  - 데이터 n과 비례하는 정도
  - O(n)
  - 데이터 개수에 선형적으로 비례
- 퀵 정렬 수행 시간
  - T(n) = T(a) + T(b) + O(n)
  - 앞의 부분배열, 데이터 개수를 모르므로 그냥 a, b로 처리
- 성능 분석_최악의 경우
  - 배열이 항상 0:n-1 또는 n-1:0으로 분할되는 경우
  - 극심한 불균형적 분할
  - 피벗만 제자리를 잡고 나머지 모든 원소가 하나의 부분배열이 되는 경우
  - 피벗이 가장 큰 값 혹은 가장 작은 값일 때
  - 데이터가 정렬된 경우 & 피벗을 배열의 처음 원소로 정한 경우
- 성능 분석_최선의 경우
  - 가장 균형적인 분할
  - 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우
- 성능 분석_평균적인 경우
  - 피벗은 동일한 확률로서 분할 후 배열의 어느 곳이나 위치 가능

#### 특징

- 최선/평균 수행 시간 -> O(nlogn)
- 최악 수행 시간 -> O(n2)
- 피벗 선택의 임의성만 보장되면 평균 성능을 보일 가능성이 매우 높음
- 배열에서 임의의 값을 선택한 후 배열의 처음 원소와 서로 교환한 후 정렬 수행
- 최악의 경우를 피할 수 있음
