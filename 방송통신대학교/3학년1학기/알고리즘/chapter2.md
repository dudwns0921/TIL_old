# 알고리즘

## 2강. 알고리즘의 기초

### 알고리즘 정의

주어진 문제를 풀기 위한 명령어들의 단계적 나열

- 입출력
  
  - 0개 이상의 외부 입력
  
  - 1개 이상의 출력

- 명확성
  
  - 각 명령은 모호하지 않고 단순 명확해야 함

- 유한성
  
  - 한정된 수의 단계를 거친 후에는 반드시 종료

- 유효성
  
  - 모든 명령은 컴퓨터에서 수행 가능해야 함

이론적으로 봤을 떄, 위 네 가지 조건을 모두 만족해야만 컴퓨터로 해결이 가능함

주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한 개의 명령들을 순서적으로 구성한 것

- 실용적 관점
  
  - 위 네 조건을 만족하더라도 시간이 너무 오래 걸린다면 실제로 해결할 수 없음
  
  - 따라서 효울적이어야 함

#### 알고리즘 생성 단계

- 설계

- 표현/기술

- 정확성 검증
  
  - 이번 학기에는 제외

- 효율성 검증

#### 알고리즘 표현/방법

- 일상 언어

- 의사코드

- 순서도

- 알고리즘을 표현하는 데에는 다양한 방법들이 있다.

### 알고리즘의 설계

#### 최댓값 찾기

- 값을 하나씩 모두 비교해 가면서 찾는 방법

- 토너먼트 방식

- 둘 다 7번 비교

- n개의 데이터에서 최댓값을 찾기 위해서는 최소 n-1번 비교

- 두 알고리즘은 동일

#### 순차 탐색 알고리즘

#### 이진 탐색

이진 탐색은 순서대로 나열된 경우에만 사용 가능

둘의 효율성 비교 자체가 불가능

#### 알고리즘 설계 기법

- 주어지는 문제, 속성, 조건 등이 매우 다양
  
  - 범용적인 설계 기법은 미존재

- 대표적인 알고리즘 설계 기법
  
  - 분할정복
  
  - 동적프로그래밍
  
  - 욕심쟁이

### 알고리즘의 분석

- 정확성 분석
  
  - 유효한 입력, 유한 시간
  
  - 정확한 결과 생성 여부
  
  - 다양한 수학적 기법을 사용해서 이론적인 증명이 필요
  
  - 정확성 분석은 이번 학기에 배우지 않음
  
  - 이번 학기에 배우는 알고리즘들은 애초에 검증이 모두 끝난 알고리즘들

- 효율성 분석
  
  - 여기에 초점을 맞출 예정
  
  - 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
  
  - 메모리 양
    
    - 공간 복잡도
    
    - 정적 공간 + 동적 공간
    
    - 생략
  
  - 수행 시간
    
    - 시간 복잡도
    
    - 여기에 초점 맞춤

- 이번 학기에 알고리즘을 분석한다는 건 시간 복잡도에 초점을 맞춰 효율성을 분석한다는 것

#### 시간 복잡도

- 구현한 알고리즘을 컴퓨터에서 실행시켜 실제 수행 시간 측정
  
  - 이 방법은 일반성 결여로 문제가 있음
    
    - 컴퓨터 속도
    
    - 프로그래밍 언어
    
    - 프로그램 작성 방법
    
    - 컴파일러의 효율성 등에 종속적

- 시간 복잡도
  
  - 알고리즘의 단위 연산의 수행 횟수의 합
  
  - 시간 복잡도에 영향을 미치는 요인
    
    - 입력 크기
      
      - 입력으로 제공되는 데이터의 크기, 문제가 해결하려는 대상이 되는 개체의 개수
      
      - 예시
        
        - 행렬의 크기
        
        - 리스트 원소의 수
        
        - 그래프 정점의 수
        
        - 입력 데이터의 상태

- 입력 크기 n이 증가하면 수행 시간도 증가
  
  - 단순히 수행되는 단위 연산의 개수의 합으로 표현하는 것은 부적절
    
    - 입력 크기 n에 대한 함수 f(n)으로 표현해야만 단순히 수행되는 수행되는 단위 연산의 개수의 합으로 표현하는 것의 문제점을 해결 가능

- 입력 데이터의 상태에 종속적
  
  - 평균 수행 시간
    
    - 입력 데이터의 모든 경우의 수를 따질 수 없음
    
    - 현실적으로 사용 불가능
  
  - 최선 수행 시간
  
  - 최악 수행 시간
    
    - 시간 복잡도로 최악 수행 시간을 사용

### 점근 성능

- 입력 크기 n이 무한대로 커짐에 따라 결정되는 성능

- n이 커지면 커질수록 최고차항만이 영향을 끼침

- 점근성능의 결정 방법
  
  - 수행 시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 표현
    
    - 수행 시간의 정확한 값이 아닌 어림값
      
      - 수행 시간의 증가 추세를 파악하는데 용이
        
        - 알고리즘의 우열 표현이 용이

#### 점근성능의 표기법

- Big-O 점근적 상한
  
  - 알고리즘 최악의 수행 시간을 표현하는 것이 Big-O 표현법

- BIg-omega 점근적 하한
  
  - 최선의 수행 시간을 나타내는 것이 omega

- BIg-theta 점근적 상하한
  
  - 상한과 하한을 동시에 갖는 경우를 theta

점근성능으로 표현하고 싶다면, 최고 차항만을 뽑아서 Big-O만 붙여주면 끝

- 주요 O 표기 간의 연산 시간의 크기 관계

데이터의 증가에 따라 상대적으로 덜 증가하는 알고리즘이 좋은 알고리즘

- 종류
  
  - 상수 시간
  
  - 로그 시간
  
  - 선형 시간
  
  - 로그 선형 시간
  
  - 제곱 시간
  
  - 세제곱 시간
  
  - 지수 시간
    
    - 실제로 사용하지 않음
    
    - 데이터 100개만 해도 너무나 횟수가 커짐

#### 알고리즘의 시간 복잡도 구하기

- 알고리즘의 시간 복잡도를 구하려면
  
  - 알고리즘의 수행 시간 f(n)을 구한 후,
  
  - f(n) = O(g(n))을 만족하는 최소 차수의 함수 g(n)을 찾음

- 실용적인 접근 방법
  
  - 알고리즘에 나타난 루프의 반복횟수를 조사하여 시간 복잡도를 취함

### 순환 알고리즘의 성능

- 순환, 재귀
  
  - 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태
    
    - 분할 정복 알고리즘은 기본적으로 순환 알고리즘으로 표현

#### 점화식의 폐쇄형 구하기

- 분할 정복 알고리즘은 순환 알고리즘으로 표현

- 그 성능은 점화식으로 표현
