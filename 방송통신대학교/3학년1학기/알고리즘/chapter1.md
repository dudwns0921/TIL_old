# 알고리즘

## 1강. 알고리즘 학습에 앞서서...

### 과목 소개

#### 컴퓨터과학에서 알고리즘의 위치

##### 컴퓨터를 사용하는 이유

데이터를 컴퓨터로 처리해 정보를 만들어내기 위함

이 과정을 데이터 처리

데이터를 처리하기 위해서는 프로그램이 필요

프로그램은 알고리즘을 기반으로 프로그래밍 언어를 통해 만들어진 것

컴퓨터과학에서 알고리즘은 필수 요소이므로 매우 중요

##### 컴퓨터 과학은 알고리즘 과학

컴퓨터과학과 관련된 모든 내용은 알고리즘과 관련된 내용을 다루고 있음

##### 컴퓨터의 한계

문제를 풀 수 있는 알고리즘 존재 여부

#### 학습 목표

잘 알려진 특정 문제를 통해 알고리즘의 설계 및 분석 방법 습득

컴퓨터 기반 문제 해결 방법에 대해 체계적으로 생각하는 훈련

주어진 문제에 대한 지적 추상화 능력 및 통찰력 향상

### 알고리즘의 필요성

#### 알고리즘은 왜 필요한가

##### 컴퓨터 과학

컴퓨터를 이용해서 주어진 문제를 해결하기 위한 학문

문제를 풀기 위해서는 절차와 방법이 필요

이 절차와 방법이 바로 알고리즘

알고리즘에서 효율성은 중요한 요소

##### 한붓 그리기

퀘닉스버그 다리 문제 -> 한붓 그리기

- 홀수점(한 점에서 연결된 선분이 홀수개인 점)이 0개 혹은 2개여야 한다
- 홀수점이 2개일 경우 홀수점에서 시작해야 한다

### 기본 자료구조

#### 자료구조와 알고리즘의 관계

##### 자료구조

- 컴퓨터에서 데이터 사이의 논리적 관계를 표현하고 조직화하는 방법
- 자료구조에 대한 고려 없는 효율적인 알고리즘의 선택 또는 알고리즘에 대한 고려 없는 효율적인 자료구조의 선택은 무의미
- 기본 자료구조
  - 선형 자료구조
    - 배열
    - 연결 리스트
    - 스택
    - 큐
  - 비선형 자료구조
    - 트리
    - 그래프

##### 배열과 연결 리스트

- 배열

  - 자료형이 같은 여러 개의 데이터를 하나의 변수에 모아놓은 집합체

  - 논리적 순서와 물리적 순서가 같음
  - 순서를 유지하는 것이 매우 중요
  - 각각의 원소에 접근하기 위해서는 인덱스를 사용
  - 검색
    - 순차 접근이 아닌 임의 접근. 인덱스를 사용해서 내가 원하는 원소에 바로 접근
  - 삽입
    - 삽입할 원소 뒤의 모든 원소들이 한 칸씩 밀려나야 함
  - 삭제
    - 삭제할 원소 뒤의 모든 원소들이 한 칸씩 앞당겨져야 함
  - 삽입과 삭제가 일어나면 자료의 이동이 무조건 발생한다. 이로 인해 시간적 오버헤드가 발생. 자료가 많을 경우 성능에 문제가 생길 수 있음
  - 이 문제를 해결하기 위해 등장한 것이 연결 리스트

- 연결 리스트

  - 노드가 연결되어 리스트를 이루고 있는 것이 연결 리스트
  - 데이터와 링크로 구성
  - 데이터는 실제 데이터가 저장되는 부분, 링크는 화살표가 저장되는 부분
  - 배열과 달리 논리적 순서와 물리적 순서가 같지 않음
  - 배열과 달리 모든 노드를 확인해야 원하는 자료를 찾을 수 있음
  - 검색
    - 데이터를 찾는 방식이 순차 접근
    - 데이터가 많으면 데이터를 찾기 쉽지 않음
  - 삽입, 삭제
    - 링크 필드만 바꿔주면 삽입과 삭제를 비교적 간단하게 수행할 수 있음

##### 배열과 연결 리스트의 종류

- 배열 종류

  - 1차원
  - 2차원
  - 3차원

- 연결 리스트 종류

  - 단일 연결 리스트
    - 방향이 한 방향
    - 한 방향으로만 노드가 연결되어 있음
    - 선행 노드를 찾을 수 없음

  - 이중 연결 리스트

    - 앞뒤로 노드가 연결되어 있음

    - 선행 노드, 후행 노드를 모두 쉽게 찾을 수 있음

  - 단일 원형 리스트
    - 처음 노드가 끝 노드와 연결되어 있음

  - 이중 원형 리스트

##### 스택과 큐

- 스택
  - 데이터의 삽입과 삭제가 한 쪽에서만 이루어지는 선형 자료구조
  - 후입선출
  - LIFO
  - top이라는 변수로 데이터가 얼마나 쌓여있는지 확인
  - top을 한 칸 올리고, top이 가리키는 위치에 데이터를 삽입
  - top을 한 칸 내리고, top이 가리키고 있었던 데이터를 삭제
- 큐
  - 한 쪽에서는 데이터의 삽입, 다른 한 쪽에서는 데이터의 삭제만 이루어지는 선형 자료구조
  - 선입선출
  - FIFO
  - 삭제가 이루어지는 곳을 front / head, 삽입이 이루어지는 곳이 rear / tail
  - rear을 한 칸 이동, rear의 자리에 데이터를 추가
  - front를 한 칸  이동, front의 자리에 데이터를 삭제

데이터의 삽입을 push, 데이터의 삭제를 pop

##### 트리

하나 이상의 노드로 구성된 유한 집합

- 조건

  - 트리의 원소 가운데 단 하나의 루트 노드가 존재
  - 루트 노드를 제외한 나머지 노드는 n개의 서로 분리된 부분집합(서브트리)으로 나누어지며, 각 서브트리는 트리가 된다.

- 주요 용어

  - 차수
    - 노드의 차수
      - 노드가 가지고 있는 서브 트리의 개수
    - 트리의 차수
      - 노드중 가장 큰 차수를 트리 차수라고 함
  - 리프 노드, 단말 노드
    - 차수가 0인 노드
  - 비단말 노드
    -  단말 노드를 제외한 나머지 노드
  - 부모 노드
    - 노드의 상위 노드
  - 자식 노드
    - 노드의 하위 노드
  - 형제 노드
    - 부모 노드를 공유하는 노드
  - 조상 노드
    - 특정 노드에서부터 루트 노드에 이르는 경로상에 있는 모든 노드
  - 후손 노드
    - 특정 노드에서부터 단말 노드에 이르는 경로상에 있는 모든 노드
  - 레벨
    - 루트 노드에서부터 특정 노드까지의 거리
  - 높이, 깊이
    - 트리 노드의 최대 레벨에 1을 더한 값

  - 숲
    - n개의 분리된 트리의 집합
    - 트리에서 루트 노드를 제거하면 숲이 됨

##### 이진 트리

각 노드의 차수가 2 이하인 순서 트리

- 순서 트리이기 때문에 노드가 같더라도 그 순서가 다르다면 다른 트리로 취급
- 노드가 아무것도 없는 공백도 이진 트리로 취급
- 레벨 i에서 최대 노드의 개수 : 2<sup>i</sup>
- 높이 h인 이진 트리의 최대 노드의 개수 : 2<sup>h</sup>-1
- n<sub>0</sub> = n<sub>2</sub>+1
  - 단말 노드의 개수는 차수가 2인 노드에 1을 더하면 됨

##### 이진 트리의 종류

- 포화 이진 트리
- 완전 이진 트리
  - 맨 마지막 레벨을 제외하면 포화 이진 트리
  - 맨 마지막 레벨에서는 왼쪽에서부터 빈 자리 없이 채워짐

- 전 이진 트리
  - 각 노드의 차수가 0이거나 2로만 이루어진 트리
- 균형 이진 트리
  - 왼쪽 서브 트리와 오른쪽 서브 트리의 높이의 차가 1이내인 트리
- 경사 이진 트리
  - 리프 노드를 제외하고 나머지 노드가 자식 노드를 하나밖에 가지지 않음

##### 이진 트리의 구현

자료구조를 컴퓨터로 구현할 때 배열, 연결 리스트중 하나를 사용

- 배열을 이용한 구현
  - 노드 개수대로 배열을 생성
  - 각 위치에 노드를 삽입
- 연결 리스트를 이용한 구현
  - 링크를 통해 각 노드의 연결을 표현

##### 그래프

정점의 집합(V)과 간선의 집합(E)을 모아놓은 자료 구조

트리와 그래프는 실생활에 정말 많이 사용되는 자료 구조

- 무방향 그래프
  - (1,2) = (2,1)
  - 예시
    - V(G<sub>1</sub>= {1,2,3,4})
    - E(G<sub>1</sub>= {(1,2),(1,3),(2,3),(2,4),(3,4)})
- 방향 그래프
  - <1,2>, 1에서 2 방향으로 연결되어있을 경우 <2,1>로는 표현할 수 없음

문제에 따라 간선에 가중치를 설정할 수 있음

이런 경우 이를 가중 그래프라고 함

##### 그래프의 구현

- 배열을 이용한 구현
  - 인접 행렬
  - 2차원 배열을 사용
  - 2차원 배열의 값이 연결 상태 또는 가중치를 나타냄
- 연결 리스트를 이용한 구현
  - 인접 리스트
  - 원래는 정점, 링크 필드를 사용
  - 각 노드에 가중치를 저장하기 위한 필드가 추가로 사용됨
