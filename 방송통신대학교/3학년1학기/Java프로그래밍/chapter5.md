# Java 프로그래밍

## 인터페이스와 다형성

### 추상 클래스

#### 추상 메소드

- 메소드 선언에 abstract 키워드를 사용함
- 몸체의 구현이 없이 형식만 존재하는 메소드
  - 반환형, 이름, 인자 선언만 존재함
  - 자식 클래스에 상속될 때, 몸체의 구현이 필요함
  - 상반된 의미의 final과 함께 사용할 수 없음
    - 자식으로 상속될 때 재정의 되어야 하는데 final은 재정의할 수 없다는 의미이기 때문

#### 추상 클래스

- 클래스 정의에 abstract 키워드 사용
  - 물론 데이터 필드나 일반 메소드를 포함할 수 있음
  - 객체 생성을 할 수 없음
    - 구체적이지 못한 불완전한 클래스라는 의미
  - 추상 메소드를 포함하는 클래스는 반드시 추상 클래스라야 함

#### 추상 클래스의 사용

- 의미적으로 유사한 클래스를 묶고자 할 때 사용
  - 공통으로 사용할 데이터 필드와 메소드를 정의
- 추상 클래스는 불완전한 클래스
  - 기능적으로 구현하기 어려운 메소드가 존재
- 추상 클래스는 자식 클래스로 상속되어 사용됨
  - 자식 클래스에서 추상 메소드를 구현해야 함
- 그러면 자식 클래스는 객체 생성이 가능
  - 자식 클래스가 추상 메소드를 구현하지 않으면 계속해서 자식 클래스도 추상 클래스로 남음
- 추상 클래스는 일반 클래스와 인터페이스의 중간적 성격을 가짐

### 인터페이스

#### Java의 인터페이스

- 100% 추상적 클래스
  - 인터페이스의 모든 메소드가 추상 메소드
  - 단, 몸체가 default 메소드와 static 메소드도 포함 가능
    - 모든 메소드의 기본 접근 제어자는 public
  - 데이터 필드는 클래스 상수만 가능(public static final)
    - 그 이유는 객체 생성이 불가능하기 때
- 참조 자료형이며 직접적 객체 생성은 불가
- 인터페이스의 이름은 보통 형용사임
  - Runnable
  - Serializable
  - Comparable

#### 인터페이스의 정의

- 문법은 클래스 정의와 유사
- 정의할 때 키워드 class 대신 interface 사용
  - abstract는 생략하는 것이 보통
- 메소드는 기본적으로 public abstract
  - 몸체가 없으며, 반환형, 이름, 매개변수 목록만 표시
- default 메소드와 static 메소드도 가능
  - 이 경우 몸체를 구현해야 함
  - 기본적으로 public
- 데이터 필드는 항상 public static final(생략 가능)임
  - 클래스 상수만 가능

#### 인터페이스의 사용

- 추상 클래스와 마찬가지로 자식 클래스에 상속되어 사용
  - 인터페이스를 상속받는 자식 클래스는 모든 추상 메소드를 구현해야 주어야 함
- 의미적으로는 관련이 없으나 기능적으로 유사한 클래스들을 묶을 때 인터페이스를 사용할 수 있음
  - 운동선수, 아파트 클래스 등등
  - 의미적으로는 전혀 관련이 없음
  - 크기와 크기를 반환하는 메소드를 인터페이스에 선언
  - 자식 클래스에서 구현
  - 그러면 자식 클래스로 생성한 객체들의 크기 비교가 가능
  - 크기 비교 기능을 가진 객체들이 생성되는 것
- 인터페이스를 상속받아 자식 인터페이스를 정의할 수 있음
  - 인터페이스의 상속 또는 확장

#### 인터페이스의 상속

- 자식 인터페이스가 부모 인터페이스를 상속받는 경우
  - 인터페이스를 상속받아 인터페이스를 정의할 때, 키워드 extends를 사용
  - 여러 인터페이스를 상속받는 다중 상속도 가능
  - 예시
    - interface 자식인터페이스 extends 부모 인터페이스, 부모 인터페이스, ... {...}

#### 인터페이스의 구현

- 자식 클래스가 부모 인터페이스를 상속받는 경우
  - 자식은 부모가 나열한 기능을 구현해야 함
  - 구현을 통해 클래스를 정의할 때 implements를 사용
- 예시
  - class MovablePoint implements Movable {...}
  - class 자식 클래스 extends
<<<<<<< HEAD
=======

#### 디폴트 메소드

- 인터페이스에서 선언하는 메소드에 기본 구현을 넣을 수 있음
  - 자식 클래스에서 상속받을 때, 디폴트 메소드를 그대로 사용하거나 몸체를 다시 정의해 줄 수 있음
  - 메소드 선언시 default를 사용하고 몸체를 구현해줌
- 인터페이스에 나열된 기능을 확장할 때, 기존 코드의 수정을 피하기 위함
  - 단순히 추상 메소드가 추가된다면, 이전 인터페이스를 구현한 클래스를 수정해야 함

#### 추상 클래스, 인터페이스, 클래스의 형변환

- 인터페이스와 클래스는 모두 사용자 정의형
- extends 와 implements 에 따라 상위/하위 자료형 관계가 설정됨
- 상위 유형의 변수는 하위 객체의 참조값을 가질 수 있음
- 상위 유형의 변수가 가리키는 객체의 실제 유형에 따라 수행되는 메소드가 결정됨(동적 바인딩)
  - 메소드 호출시, 변수의 선언 유형으로 정하지 않음
  - 예 : SuperClass super = new SubClass();
  - super.method(); // SubClass에서 찾음

### 다형성

#### 다형성

- 다형성
  - 유사하지만 다양한 형상이나 다양한 기능을 가진다는 뜻
  - 한 부모에서 나온 두 자식 객체는 비슷하지만 다름
  - 하나의 클래스에서 오버로딩된 메소드들은 유사하지만 조금씩 다른 기능을 수행함
  - 자식 클래스에서 재정의된 메소드는 부모의 것과 유사하지만 다른 기능을 수행함
- 다형성과 형변환
  - 상속 관계에 있는 클래스 간에는 타입 변환이 가능함
    - 전혀 다른 두 클래스 간에는 타입 변환이 금지됨
  - 하위 클래스에서 상위 클래스로의 형 변환은 문제 없음
    - 업캐스팅이라 하며 자동으로 형변환 가능함
    - 참조형 변수는 같은 유형의 객체 또는 하위 객체를 참조할 수 있음

#### 다형성과 오버라이딩

- 클래스의 다형성
  - 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 오버라이딩할 수 있음
  - 부모와 자식에서 같은 이름의 메소드가 다른 기능을 수행
    - 같은 이름과 매개 변수 및 반환형을 가지나 몸체가 다름
- 인터페이스의 다형성
  - 자식 클래스들에서 상위 인터페이스의 메소드를 다르게 구현함

### 열거 자료형

#### 열거형 정의

- 열거형은 미리 정의된 상수값을 만들기 위한 자료형
- enum을 사용하여 정의
- 열거형으로 선언된 변수에는 미리 지정된 값만 대입 가능
- 상수값을 배열로 리턴하는 static 메소드로 values() 를 제공

#### 열거형의 생성자와 메소드

- 상수 선언이 필드나 메소드보다 먼저 정의되어야 하며 세미콜론(;)으로 끝나야 함
- 열거형 정의에 필드와 메소드를 포함할 수 있음
- 생성자는 열거형과 같은 이름을 가지며 접근 제어자는 생략 또는 private 이어야 함
- 열거형에서 상수값은 마치 하나의 객체와 같음
- 열거형의 생성자는 상수값을 설정할 때 자동 호출됨

### 익명 클래스

#### 익명 클래스

- 일회성으로 1개의 객체를 생성하기 위한 클래스
  - 클래스 정의와 동시에 객체를 생성할 수 있음
- 슈퍼 클래스를 상속받거나 인터페이스를 구현하도록 익명 클래스를 정의함
  - new 슈퍼클래스() {...} // 슈퍼클래스의 자식 객체 생성
  - new 인터페이스() {...} // 인터페이스를 구현하는 자식 객체 생성
  - 중괄호가 익명 클래스의 몸체

#### 클래스를 상속받는 익명 클래스

>>>>>>> 9c02871ec950cad5c07ca9182224f31987ab164c
