# Java 프로그래밍

## 클래스와 상속

### 클래스 정의와 상속

#### 메소드 정의

- 클래스 정의 내부에 존재함
- 헤더와 몸체로 구성됨

#### 생성자

- 객체가 생성될 때 자동으로 실행되는 메서드
  - 객체의 필드 값을 초기화하거나 메모리 할당 등의 작업
- 객체 생성 방법은 new 클래스이름(인자...)
- 예
  - Circle c = new Circle(5)
  - new 연산자를 이용하여 객체를(메모리 할당)하고
  - 생성자가 호출(데이터 필드의 초기화)되면서
  - 객체의 참조값을 변수에 대입

#### 생성자 정의(1)

- 보통의 메서드와 정의 방법 다름
  - new 로 객체 생성시 자동으로 호출
- 정의 방법
  - 생성자 이름은 클래스 이름과 같음
  - Circle 생성자는 Circle
  - 반환형을 작성하지 않음
  - 여러 생성자를 작성 가능(생성자 오버로딩)
    - 인자의 개수와 인자의 자료형으로 구분
  - 접근 제어자는 보통 public

#### 생성자 정의(2)

- 접근 제어자가 없으면 동일한 패키지의 다른 클래스에서 사용 가능
- 하나의 소스 파일 안에 있으면 동일한 패키지에 존재

#### 기본 생성자

- 인자가 없는 생성자, 디폴트 생성자
- 클래스 정의에 한 개의 생성자 정의도 없으면 컴파일러가 다음을 자동으로 만들어줌
  - public Circle() {}
  - 생성자 몸체의 첫 줄에 부모 생성자의 명시적 호출이 없다면 다음 코드가 자동으로 들어감
    - super(); // 부모 클래스의 기본 생성자를 호출
    - 따라서 부모 클래스에서 기본 생성자의 존재를 확인해야 함

#### 클래스의 사용

- 상속을 위해 사용하는 것
  - extends
- 변수를 선언하고 객체를 생성
  - 클래스 참조형 변수의 선언
    - Circle c;
    - c= new Circle(5);

#### 객체의 사용

- 객체 변수와 점 연산자를 사용하여 멤버에 접근
  - 객체가 소유하는 데이터(인스턴스 변수)를 읽거나 쓰기
  - 객체를 이용하여 메서드(인스턴스 메서드)를 호출하기

#### static 필드

- 정적 필드 or 클래스 변수
- 클래스의 모든 객체가 공유하는 데이터
  - 객체의 생성이 없어도 항상 사용 가능
  - 어떤 객체도 값을 변경할 수 있음
- 사용 방법은 클래스 이름.정적필드
  - 객체변수.정적필드도 가능
  - 인스턴스.정적필드도 가능하지만 클래스 변수임을 표현하기 위해 Circle.정적필드 권장

#### static 메서드

- static 메서드
  - 정적 메서드 or 클래스 메서드
  - 객체와 무관하게 호출되고 실행됨
    - 메서드 몸체에서 this를 사용할 수 없음
  - static 필드와 인자를 가지고 작업함
  - 사용 방법은 클래스 이름.정적메서드()
    - Math.sqrt(2.0);
    - Integer.parseInt("120");

#### final 필드와 final 메서드

- final 필드
  - 상수 데이터를 선언
  - 선언할 때 초기값을 지정해야 함
  - 자주 static과 함께 사용됨
    - final static double PI = 3.141592;
    - final만 붙이면 각 인스턴스마다 해당 필드가 생성됨
    - 하지만 PI는 유일한 값으로 클래스 변수로 선언하는 것이 효율적
- final 메서드
  - 자식 클래스로 상속은 가능하나 재정의 할 수 없는 메서드
  - final 클래스의 경우 부모 클래스로 사용할 수 없음

#### 객체 초기화

- 객체를 생성할 때, 데이터 필드에 초기값을 지정하는 것

  - 클래스 변수는 프로그램 시작시 자동 초기화됨

- 데이터 필드는 자동으로 초기값이 주어질 수 있음

  - 데이터 필드는 기본적으로 0으로 초기화됨(숫자의 경우), 실제로 이렇게 기본값으로 놔두는 건 좋은 방법은 아님

- 방법

  - static 필드의 선언문에서 초기화

  - static 초기화 블록 실행

    - static 블록은 일반 블록 앞에 static만 붙여주면 된다.

  - non-static 필드의 선언문에서 초기화

  - non-static 초기화 블록 실행

    - 클래스 몸체 내 임의 위치에 포함
    - 초기값 지정을 위한 코드
    - static  필드는 static 블록을 사용

  - 생성자 실행

    - 사실 위의 과정들은 생성자 블록에서 수행이 가능하기 때문에 큰 의미는 없지만 위와 같은 과정이 수행된다는 건 기억하기


#### 메소드 오버로딩

- 인자의 개수나 인자의 자료형이 다르면 같은 이름의 메소드를 한 클래스에서 여러 개 정의할 수 있음
  - 인자의 개수와 자료형이 정확히 일치하면 중복 정의 불가
  - 이름, 매개변수 리스트 -> 메소드 시그니처
  - 이를 통해서 메소드를 구분할 수 있음
  - 반환형은 구분하는 기준이 될 수 없음
- 메소드가 호출될 때, 가장 가까운 매개변수 목록을 가진 메소드가 호출됨

### 상속

#### 클래스의 재사용

- 합성
  - 기존 클래스를 새로운 클래스에서 데이터 필드의 자료형으로 사용
  - has-a 관계
  - class Line { Point begin, end; ... }
  - 두 개의 점을 가지는 라인
- 상속
  - 기존 클래스(부모)를 사용하여 새로운 클래스(자식)를 정의
  - 코드의 중복 작성을 줄이고 프로그램의 확장성이 좋아짐
  - 상속은 기존 클래스를 확장 or 특화하는 것
  - 자식 is-a 부모의 관계

#### 클래스의 상속

- 상속은 부모 클래스와 자식 클래스 간의 관계
  - 자식 클래스가 부모 클래스의 필드와 메소드를 상속 받음
  - 기존 클래스를 상속받을 때 키워드 extends를 사용함
  - class Manager extends Employee {...}
  - 자식 클래스에서 상속받은 메소드를 오버라이딩할 수 있음
- 클래스의 상속은 단일 상속만 가능
  - 인터페이스 상속의 경우는 다중 상속 가능
- 상속하더라도 각각의 클래스의 private 변수나 메서드는 접근할 수 없음

#### 메소드 오버라이딩

- 부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 재정의하는 것
- 부모와 자식에서 같은 이름의 메소드가 다른 기능을 수행하게 됨
- 메소드의 이름, 인자의 개수와 자료형, 반환형이 같은 메소드를 정의
- 반환형은 서브 타입(상속 관계에서 자식 클래스) 도 가능함
- 접근 제어자의 가시성(접근 범위)는 같거나 커져야 함
  - protected인 경우 protected 또는 public
  - public 인 경우 public만 가능

#### this

- 메소드 호출시, 숨은 인자로 this가 메소드에 전달됨
  - this는 현재 객체에 대한 참조값을 가지고 있음
  - c1.display()와 c2.display()의 결과가 다른 이유임
- 인스턴스 메소드나 생성자에서만 사용 가능
- this는 생략 가능

#### super

- this와 같으나 자료형이 부모 클래스 유형
- 부모 this
- 자식 클래스의 인스턴스 메소드나 생성자에서 사용됨
  - this와 마찬가지로 static 메소드에서 사용할 수 없음
- 부모 클래스에서 오버로딩 당한 메소드를 호출하거나 상속되었으나 감춰진 필드에 접근할 때 필요함
- 부모 유형 클래스에 자식 클래스 생성자로 만든 변수를 할당할 수 있음

#### this()와 super()

- this()
  - 같은 클래스의 다른 생성자를 호출하는 것
- super()
  - 부모 클래스의 생성자를 호출하는 것
  - 상속받은 데이터 필드를 초기화하기 위한 것
  - 생성자 몸체에서 부모 클래스 생성자의 명시적 호출이 없다면, 인자가 없는 생성자인 super()가 자동 호출됨
- 둘 다 생성자 몸체의 첫 번째 문장에서만 사용 가능

