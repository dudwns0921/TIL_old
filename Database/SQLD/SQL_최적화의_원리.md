# SQL 최적화의 원리

# 1.  옵티마이저와 실행 원리

# 1-1. 옵티마이저

- 옵티마이저는 SQL을 어떻게 실행할 것인지를 계획하고 실행하는 소프트웨어이다.
- 동일한 결과가 나오는 SQL도 어떻게 실행하느냐에 따라 성능이 달라지기 때문에 옵티마이저의 실행 계획은 매우 중요하다.



# 1-2. 옵티마이저 특징

- 옵티마이저는 데이터 딕셔너리에 있는 오브젝트 통계, 시스템 통계 등의 정보를 사용해서 예상되는 비용을 산정한다.
- 옵티마이저는 여러 개의 실행 계획 중에서 최저 비용을 가지고 있는 계획을 선택해서 SQL을 실행한다.
- 옵티마이저가 비효율적으로 실행 계획을 수립하면 개발자는 힌트를 통해 실행 계획을 변경하도록 요청할 수 있다.



# 2. 옵티마이저 종류

# 2-1. 옵티마이저의 실행 방법

- 개발자가 SQL을 실행하면 파싱을 실행해서 SQL의 문법 검사 및 구문분석을 수행한다.
- 구문분석이 완료되면 옵티마이저가 규칙 기반 혹은 비용 기반으로 실행 계획을 수립한다.
- 옵티마이저는 기본적으로 비용 기반 옵티마이저를 사용해서 실행 계획을 수립한다.
- 실행 계획 수립이 완료되면 최종적으로 SQL을 실행하고 실행이 완료되면 데이터를 인출한다.

### > 옵티마이저 엔진

| 옵티마이저        | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| Query Transformer | SQL문을 효율적으로 실행하기 위해서 옵티마이저가 변환한다.<br />SQL이 변환되어도 그 결과는 동일하다. |
| Estimator         | 통계정보를 사용해서 SQL 실행비용을 계산한다.<br />총비용은 최적의 실행 계획을 수립하기 위해서이다. |
| Plan Generator    | SQL을 실행할 계획을 수립한다.                                |



# 3. 인덱스

# 3-1. 인덱스

- 인덱스는 인덱스키로 정렬되어 있기 때문에 원하는 데이터를 빠르게 조회한다.
- 인덱스는 오름차순 및 내림차순 탐색이 가능하다. (Leaf Block은 Double Linked 형태로 되어 있어서 양방향 탐색이 가능하다.)
- 하나의 테이블에 여러 개의 인덱스를 생성할 수 있고 하나의 인덱스는 여러 개의 칼럼으로 구성될 수 있다.
- 테이블을 생성할 때 기본키는 자동으로 인덱스가 만들어지고 인덱스의 이름은 SYSXXXX이다.

- 인덱스의 구조는 Root Block, Branch block, Leaf Block으로 구성되고 Root Block은 인덱스 트리에서 가장 상위에 있는 노드를 의미한다.
- Branch Block은 다음 단계의 주소를 가지고 있는 포인터로 되어있다.
- Leaf Block은 인덱스 키와 ROWID로 구성되고 인덱스 키는 정렬되어 저장되어 있다.
- Leaf Block에서 인덱스 키를 읽으면 ROWID를 사용해서 테이블의 행을 직접 읽을 수 있다.



# 3-2. 인덱스 스캔

## (1) 인덱스 유일 스캔

- Index Unique SCAN은 인덱스의 키 값이 중복되지 않는 경우, 해당 인덱스를 사용할 때 발생된다.



## (2) 인덱스 범위 스캔

- Index Range SCAN은 select문에서 특정 범위를 조회하는  where문을 사용할 경우 발생한다.
- like나 between이 그 대표적인 예이다. 물론 데이터 양이 적은 경우는 인덱스 자체를 실행하지 않고 TABLE FULL SCAN이 될 수 있다.
- Index Range SCAN은 인덱스의 Leaf Block의 특정 범위를 스캔한 것이다.



## (3) 인덱스 전체 스캔

- 인덱스에서 검색되는 인덱스 키가 많은 경우에 Leaf Block의 처음부터 끝까지 전체를 읽어 들인다.



# 4. 옵티마이저 조인

# 4-1. Nested Loop 조인

- 하나의 테이블에서 데이터를 먼저 찾고 그 다음 테이블을 조인하는 방식으로 실행된다.
- 먼저 조회되는 테이블을 외부 테이블이라고 하고 그 다음 조회되는 테이블을 내부 테이블이라고 한다.
- Nested Loop 조인에서는 외부 테이블의 크기가 작아야 데이터가 스캔되는 범위를 줄일 수 있다.
- 순서는 다음과 같다.

외부 테이블, outer table의 인덱스를 검색하고, 그 인덱스에 있는 ROWID를 이용해서 해당 테이블을 읽는다.

그 다음에는 내부 테이블의 인덱스를 찾는데, 이를 RANDOM ACCESS라고 한다.(RANDOM ACCESS가 적어야 성능이 향상된다.)

RANDOM ACCESS를 사용해서 찾은 인덱스로 내부 테이블에서 데이터를 찾고, 인출을 실행해서 전송한다.



# 4-2. Sort Merge 조인

- Sort Merge 조인은 두 개의 테이블을 SORT_AREA라는 메모리 공간에 모두 로딩하고 SORT를 수행한다.
- 두 개의 테이블이 SORT가 끝나면 병합한다.
- 정렬이 발생하기 때문에 데이터양이 많아지면 성능이 떨어지게 된다.
- 정렬 데이터양이 너무 많으면 정렬은 임시 영역에서 수행된다. 임시 영역은 디스크에 있기 때문에 성능이 급격히 떨어진다.



# 4-3. Hash 조인

- Hash 조인은 두 개의 테이블 중에서 작은 테이블을 HASH 메모리에 로딩하고 두 개의 테이블의 조인 키를 사용해서 해시 테이블을 생성한다.
- Hash 조인은 해시 함수를 사용해서 주소를 계산하고 해당 주소를 사용해서 테이블을 조인하기 때문에 CPU 연산을 많이 한다.
- 특히 Hash 조인 시에는 선행 테이블이 충분히 메모리에 로딩되는 크기여야 한다.



