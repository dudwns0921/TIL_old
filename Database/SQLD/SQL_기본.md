# SQL 기본

# 1. 관계형 데이터베이스

# 1-1. 관계형 데이터베이스

## 1) 관계형 데이터베이스의 등장

- 관계형 데이터베이스는 릴레이션과 릴레이션의 조인을 연산을 통해서 합집합, 교집합, 차집합 등을 만들 수 있다.

릴레이션 : 주로 테이블과 같은 의미로 사용되지만, 테이블이 릴레이션보다 큰 의미이다.

따라서 모든 릴레이션은 테이블이 될 수 있지만 모든 테이블은 릴레이션이 될 수 없다.



## 2) 데이터베이스와 데이터베이스 관리 시스템의 차이점

- 데이터베이스의 종류

  - 계층형 데이터베이스 : 1대N 관계를 표현한다.

  - 네트워크형 데이터베이스 : 1대N과 M대N 관계도 표현 가능하다.

  - 관계형 데이터베이스 : 릴레이션에 데이터를 저장하고 관리한다.

    | 종목코드 | 종목명   |
    | -------- | -------- |
    | S1000    | 삼성전자 |
    | S1002    | 국민은행 |
    | S1003    | 대신증권 |
  
  - 데이터베이스를 관리하는 것이 데이터 베이스 관리 시스템(DBMS)이다.



## 3) 관계형 데이터베이스 집합 연산과 관계 연산

- 집합 연산

| 집합 연산                 | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 합집합(Union)             | 두 개의 릴레이션을 하나로 합하는 것이다.<br />중복된 행은 한 번만 조회한다. |
| 차집합(Difference)        | 본래 릴레이션에만 존재하고 다른 릴레이션에 존재하지 않는 것을 조회 |
| 교집합(Intersection)      | 두 개의 릴레이션들 중 공통된 것 조회                         |
| 곱집합(Cartesian product) | 각 릴레이션에 존재하는 모든 데이터를 조합 후 연산            |

- 관계 연산

| 관계 연산   | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| 선택 연산   | 릴레이션에서 조건에 맞는 행만을 조회                         |
| 투영 연산   | 릴레이션에서 조건에 맞는 속성만을 조회                       |
| 결합 연산   | 여러 릴레이션의 공통된 속성을 사용해서 새로운 릴레이션 생성  |
| 나누기 연산 | 기준 릴레이션에서 나누는 릴레이션이 가지고 있는 속성과 동일한 값을 가지는 행을 추출하고<br />나누는 릴레이션의 속성 삭제 후 중복된 행을 제거하는 연산 |

## 2. 테이블의 구조

- 기본키(Primary key) : 하나의 테이블에서 유일성과 최소성, Not Null을 만족하면서 해당 테이블을 대표하는 것
- 테이블은 행과 칼럼으로 구성되며, 그 중에서 행은 하나의 테이블에 저장되는 값으로 튜플이라고도 함
- 칼럼은 어떤 데이터를 저장하기 위한 필드로 속성이라고도 함
- 외래키는 다른 테이블의 기본키를 참조하는 칼럼

# 2. SQL 종류

# 2-1. SQL

- SQL은 ANSI/ISO 표준을 준수하기 떄문에 데이터베이스 관리 시스템이 변경되어도 사용 가능



# 2-2. SQL 종류

## (1) SQL의 종류

| 종류                              | 설명                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| DDL(Data Definition Language)     | 관계형 데이터베이스 구조 정의<br />create, alter, drop, rename 등 |
| DML(Data Manipulation Language)   | 테이블에 데이터 입력, 수정, 삭제, 조회<br />insert, update, delete, select 등 |
| DCL(Data Control Language)        | 데이터베이스 사용자에게 권한 부여하거나 회수<br />grant, revoke, truncate |
| TCL(Transaction Control Language) | 트랜잭션 제어<br />commit, rollback, savepoint               |

## (2) 트랜잭션

- 트랜잭션은 데이터베이스의 작업을 처리하는 단위

| 트랜잭션 특성 | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 원자성        | 트랜잭션의 처리가 완전히 끝나지 않았을 경우는 실행되지 않은 상태와 같아야 한다. |
| 일관성        | 트랜잭션 실행 결과로 데이터베이스의 상태가 모순되지 않아야 한다. |
| 고립성        | 트랜잭션 실행 중에 생성하는 연산의 중간결과는 다른 트랜잭션 접근 불가 |
| 영속성        | 트랜잭션이 그 실행을 성공적으로 완료하면 그 결과는 영구적 보장이 되어야 한다. |

## (3) SQL문의 실행 순서

1. 파싱(Parsing) : SQL문의 문법을 확인하고 구문분석
2. 실행(Execution) : 옵티마이저가 수립한 실행 계획에 따라 SQL 실행
3. 인출(Fetch) : 데이터 읽어서 전송



# 3. DDL

# 3-1. 테이블 생성

## (1) CASCADE 옵션

- CASCADE 옵션은 참조 관계가 있을 경우 참조되는 데이터를 자동으로 반영할 수 있는 것

```sql
constraint fk foreign key (deptno)
		references dept(deptno)
		on delete cascade
-- 현재 emp라는 직원 정보 테이블에서 부서 정보가 있는 dept 테이블을 참조중
```

- 테이블 생성시 외래키를 추가할 때 아래에 **ON DELETE CASCADE** 구문을 추가
- 자신이 참조하고 있는 테이블의 데이터가 삭제되면 자동으로 자신도 삭제되는 옵션
- 이로 인해 참조 무결성 준수 가능

## (2) 테이블 변경

```sql
alter table emp
	rename to new_emp;
	rename column ename to new_ename;
-- 테이블명 변경
-- 칼럼명 변경

alter table emp
	add (age number(2));
-- 테이블에 칼럼 추가

alter table emp
	modify (ename varchar2(30) not null);
-- 칼럼 정보 변경, 이 때 칼럼에 데이터가 존재하면 오류가 발생

alter table emp
	drop column age;
-- 칼럼 삭제
```

## (3) 테이블 삭제

```sql
drop table dept;
ORA-02449: unique/primary keys in table referenced by foreign keys
-- 오류 발생

drop table dept cascade constraints;

-- emp테이블이 dept테이블을 참조하고 있는 상황
-- 부모 테이블이 dept, 자식 테이블이 emp
-- dept 테이블을 삭제하기 위해서는 cascade constraints 옵션 추가
```

## (4) 뷰 생성과 삭제

- 뷰는 테이블로부터 유도된 가상의 테이블
- 실제 데이터를 가지고 있지 않고 테이블을 참조해서 원하는 칼럼만을 조회
- 뷰의 특징
  - 참조된 테이블이 변경되면 뷰도 변경
  - 뷰 입력, 수정, 삭제에는 제약이 있음
  - 특정 칼럼만 조회시키기 때문에 보안성 향상
  - 한 번 생성된 뷰는 수정 불가, 삭제 후 재생성해야 함
  - alter문으로 변경 불가

```sql
create view v_emp as
select * from emp;

select * from v_emp;
-- 일반 테이블처럼 조회
```



# 4. DML

# 4-1. INSERT 문

```sql
insert into emp(empno, ename) values(1000, "정영준");
insert into emp values(1000, "정영준");
```

- 2번째 예시처럼 칼럼명을 생략할 수도 있는데, 이 때 칼럼은 숫자형 데이터 한 개의 칼럼과 문자형 데이터 타입 한 개의 칼럼만 있어야 한다.

- 주의할 점은 TCL문인 commit을 실행해야만 데이터가 테이블에 삽입된다는 점이다.

   

## (1) Select문으로 입력

```
insert into dept_test
select * from dept;
```

- 위의 예시처럼 select문으로 조회한 데이터를 해당 테이블에 한 번에 삽입할 수 있다.
- 다만 입력되는 테이블은 사전에 생성되어 있어야 하며, 조회한 테이블과 데이터를 삽입하려는 테이블의 칼럼이 동일해야 한다.



## (2) Nologging

- 데이터베이스에 데이터를 입력하면 로그파일에 그 정보를 기록한다.
- Check point라는 이벤트가 발생하면 로그파일의 데이터를 데이터 파일에 저장한다.
- Nologging 옵션은 로그파일의 기록을 최소화시켜서 입력 시 성능을 향상시키는 방법이다.
- Nologging 옵션은 Buffer Cache라는 메모리 영역을 생략하고 기록한다.



# 4-2. DELETE문

## > 테이블의 모든 데이터 삭제

| Delete                                                       | Truncate                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 테이블의 모든 데이터 삭제<br />데이터가 삭제되어도 테이블의 용량은 감소하지 않음 | 테이블의 모든 데이터 삭제<br />데이터가 삭제되면 테이블의 용량도 초기화 |



# 4-4. SELECT문

## (1) order by를 사용한 정렬

- order by는 정렬을 하기 때문에 데이터베이스 메모리를 많이 사용하게 된다.

  즉, 대량의 데이터를 정렬하게 되면 성능 저하가 발생

- Oracle 데이터베이스는 정렬을 위해서 메모리 내부에 할당된 SORT_AREA_SIZE를 사용한다.

  만약 SORT_AREA_SIZE가 너무 작으면 성능 저하가 발생

- 정렬을 회피하기 위해 인덱스를 생성할 때 사용자가 원하는 형태로 오름차순 혹은 내림차순으로 생성해야 한다.



## (2) index를 사용한 정렬 회피

- 정렬은 Oracle 데이터베이스에 부하를 주므로, 인덱스를 사용해서 Order by를 회피할 수 있다.

```sql
select /* index_desc(A) */
from EMP A;
```

- 위의 예시를 보면 힌트를 사용해 EMP 테이블에 생성된 인덱스를 내림차순으로 읽게 지정한 것을 알 수 있다.



# 5. WHERE문 사용

## (1) NULL 값 조회

- NULL은 값의 부재를 의미
- NULL 연산, 할당 비교가 불가능하다.
- NULL을 조회할 경우는 IS NULL을 사용하고 NULL 값이 아닌 것을 조회할 경우는 IS NOT NULL을 사용한다.



| NULL 함수   | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| NVL 함수    | NULL이면 다른 값으로 바꾸는 함수                             |
| NVL2 함수   | NVL 함수와 DECODE 함수를 하나로 만든 것<br />`NVL2(MGR, 1, 0)`은 MGR 칼럼이 NULL이 아니면 1을, NULL이면 0을 반환 |
| NULLIF 함수 | 두 개의 값이 같으면 NULL을, 같지 않으면 첫 번째 값을 반환<br />`NULLIF(exp1, exp2)`은 exp1과 exp2가 같으면 NULL을, 같지 않으면 exp1을 반환 |
| COALESCE    | NULL이 아닌 최초의 인자 값을 반환<br />`COALESCE(exp1, exp2, ...)`은 exp1이 NULL이 아니면 exp1의 값을, 그렇지 않으면 그 뒤의 값의 NULL 여부를 판단하여 값을 반환 |



# 6. SELECT문 실행 순서

**FROM, WHERE, GROUP BY, HAVING, SELECT, ORDER BY**순으로 실행



# 7. 명시적 형변환과 암시적 형변환

- 형변환이라는 것은 두 개의 데이터의 데이터 타입이 일치하도록 변환하는 것이다.
- 명시적 형변환은 형변환 함수를 사용해서 데이터 타입을 일치시키는 것

| 형변환 함수                     | 설명                                              |
| ------------------------------- | ------------------------------------------------- |
| TO_NUMBER(문자열)               | 문자열을 숫자로 변환한다.                         |
| TO_CHAR(숫자 혹은 날짜, FORMAT) | 숫자 혹은 날짜를 지정된 FORMAT의 문자로 변환한다. |
| TO_DATE(문자열, FORMAT)         | 문자열을 지정된 FORMAT의 날짜형으로 변환한다.     |

- 암시적 형변환은 개발자가 형변환을 하지 않은 경우 데이터베이스 관리 시스템이 자동으로 형변환하는 것



## > 인덱스 칼럼에 형변환을 수행하면 인덱스를 사용하지 못한다.

이와 같은 경우에는 명시적 형변환을 사용하면 해결할 수 있다.



# 8. 내장형 함수

| 문자열 함수              | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ASCll(문자)              | 문자 혹은 숫자를 ASCll 코드값으로 변환                       |
| CHAR(ASCll 코드값)       | ASCll 코드값을 문자로 변환                                   |
| SUBSTR(문자열, m, n)     | 문자열에서 m번째 위치부터 n개를 자른다.                      |
| CONCAT(문자열1, 문자열2) | 문자열1번과 2번을 결합<br />오라클은 \|\|, MS-SQL은 + 사용 가능 |
| LOWER(문자열)            | 영문자를 소문자로 변환                                       |
| UPPER(문자열)            | 영문자를 대문자로 변환                                       |
| LENGTH 혹은 LEN(문자열)  | 공백을 포함해서 문자열의 길이를 알려줌                       |
| LTRIM(문자열, 지정문자)  | 왼쪽에서 지정된 문자를 삭제<br />지정된 문자를 생략하면 공백을 삭제 |
| RTRIM(문자열, 지정문자)  | 오른쪽에서 지정된 문자를 삭제<br />지정된 문자를 생략하면 공백을 삭제 |
| TRIM(문자열, 지정문자)   | 왼쪽 및 오른쪽에서 지정된 문자를 삭제<br />지정된 문자를 생략하면 공백을 삭제 |

| 날짜형 함수                                   | 설명                                  |
| --------------------------------------------- | ------------------------------------- |
| SYSDATE                                       | 오늘의 날짜를 날짜 타입으로 알려준다. |
| EXTRACT('YEAR' \| 'MONTH' \| 'DAY' from dual) | 날짜에서 년, 월, 일을 조회            |

| 숫자형 함수        | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| ABS(숫자)          | 절댓값을 돌려준다.                                           |
| SIGN(숫자)         | 양수, 음수, 0을 구별한다.                                    |
| MOD(숫자1, 숫자2)  | 숫자1을 숫자2로 나누어 나머지를 계산한다.<br />%을 사용해도 된다. |
| CEIL/CEILING(숫자) | 숫자보다 크거나 같은 최소의 정수를 돌려준다.                 |
| FLOOR(숫자)        | 숫자보다 작거나 같은 최대의 정수를 돌려준다.                 |
| ROUND(숫자, m)     | 소수점 m 자리에서 반올림한다.<br />m의 기본값은 0이다.       |
| TRUNC(숫자, m)     | 소수점 m 자리에서 절삭한다.<br />m의 기본값은 0이다.         |



# 9. DECODE와 CASE문

# 9-1. DECODE문

```sql
decode(empno, 1000, 'TRUE', 'FALSE');
```

empno=1000일 경우 TRUE 출력, 다르면 FALSE 출력



# 9-2. CASE문

```sql
select
case
	when empno = 1000 then 'A'
	when empno = 1001 then 'B'
	else 'C'
from emp;
```

empno가 1000이면 A 출력, empno가 1001면 B 출력, 그외에는 C 출력



# 10. ROWNUM과 ROWID

# 10-1. ROWNUM

- rownum은 오라클 데이터베이스의 select문 결과에 대해서 논리적인 일련번호를 부여한다.
- rownum은 조회되는 행 수를 제한할 때 많이 사용된다.
- rownum을 사용해서 페이지 단위 출력을 하기 위해서는 인라인 뷰를 사용해야 한다.



# 10-2.ROWID

- rowid는 오라클 데이터베이스 내에서 데이터를 구분할 수 있는 유일한 값이다.
- rowid를 통해서 데이터가 어떤 데이터 파일, 어느 블록에 저장되어 있는지 알 수 있다.

| 구조           | 길이  | 설명                                                         |
| -------------- | ----- | ------------------------------------------------------------ |
| 오브젝트 번호  | 1~6   | 오브젝트 별로 유일한 값을 가지고 있으며, 해당 오브젝트가 속해 있는 값이다. |
| 상대 파일 번호 | 7~9   | 테이블스페이스에 속해 있는 데이터 파일에 대한 상대 파일번호이다. |
| 블록 번호      | 10~15 | 데이터 파일 내부에서 어느 블록에 데이터가 있는지 알려준다.   |
| 데이터 번호    | 16~18 | 데이터 블록에 데이터가 저장되어 있는 순서를 의미한다.        |



# 11. With구문

- with구문은 서브쿼리를 사용해서 임시 테이블이나 뷰처럼 사용할 수 있는 구문
- 서브쿼리 블록에 별칭 지정 가능
- view와 다른 점이 있다면, view는 삭제할 때까지 없어지지 않지만 with절은 정의된 쿼리문 내에서만 사용이 가능하다.

```sql
with viewData as
(select * from emp)
```

emp 테이블 전체를 가지는 viewData라는 임시 테이블을 만듦.



# 12. DCL(Data Control Language)

# 12-1. GRANT

- grant문은 데이터베이스 사용자에게 권한을 부여

```sql
grant privileges on table_name to user;
```

| 권한(privileges에 들어갈 수 있는 권한) |
| -------------------------------------- |
| select                                 |
| insert                                 |
| update                                 |
| delete                                 |
| references                             |
| alter                                  |
| index                                  |
| all                                    |

```sql
grant privileges on table_name to user
with grant option 
/*or admin option;*/
```

| GRANT 옵션        |                                                              |
| ----------------- | ------------------------------------------------------------ |
| with grant option | 특정 사용자에게 권한을 부여할 수 있는 권한을 부여<br />권한을 회수할 때 권한을 회수한 사용자가 권한을 부여한 사용자들의 권한도 회수한다. |
| with admin option | 테이블에 대한 모든 권한을 부여<br />권한을 회수할 때 권한을 회수한 사용자의 권한만 회수된다. |





# 12-2. REVOKE

- revoke문은 데이터베이스 사용자에게 부여된 권한을 회수한다.



# 13. TCL

# 13-1.COMMIT

- commit은 insert, update, delete문으로 변경한 데이터를 데이터베이스에 반영한다.
- 변경 이전 데이터는 없어진다.
- 다른 모든 데이터베이스 사용자는 변경된 데이터를 볼 수 있다.
- commit이 완료되면 데이터베이스의 변경으로 인한 락이 해제된다. --> 고립성
- commit이 완료되면 다른 데이터베이스 사용자는 변경된 데이터를 조작할 수 있다.
- commit이 실행되면 하나의 트랜잭션 과정을 종료한다.



# 13-2. ROLLBACK

- 데이터에 대한 변경 사용을 모두 취소하고 트랜잭션을 종료
- 이전에 commit한 곳 이전까지 insert, update, delete문의 작업을 모두 취소
- rollback을 실행하면 락이 해제되고 다른 사용자도 데이터베이스 행을 조작할 수 있다.



# 13-3. SAVEPOINT

- savepoint는 트랜잭션을 작게 분할하여 관리하는 것으로 savepoint를 사용하면 지정된 위치 이후의 트랜잭션만 rollback할 수 있다.

```sql
savepont t1;
...
rollback to t1;
```

savepoint t1를 설정하고 설정한 savepoint로 rollback한다.

