# 인덱스

b-tree 인덱스

비트맵 인덱스

IOT

클러스터형



흔히 사용하는 것은 비트리

테이블을 생성할 때 오브젝트를 생성한다고 함

인덱스도 마찬가지

오브젝트의 하나로 테이블과 매핑된 또다른 테이블이 생성된다고 생각하면 쉬움



테이블이 하나 더 생성 -> 속도 어떻게 빨라지는



인덱스 칼럼을 기준으로 정렬되어 저장

보통 테이블의 데이터들은 물리적으로 흩어져서 저장되어 있어서

특정 조건의 데이터들을 찾으려면 테이블 풀 스캔을 해야함

데이터가 방대하면 시간이 오래 걸림



인덱스는 정렬이 되어있기 때문에 특정 조건에 따라 바로 검색을 할 수 있음



인덱스에서 먼저 데이터들을 찾은 후 그 테이블로 매핑된 곳을 가서 나머지 데이터들을 꺼내오는 방식

매핑 방식은 객체지향에서의 포인터처럼

인덱스가 해당 테이블의 블록 주소를 가지고 있다고 생각하면 됨



블럭은 데이터가 저장되는 최소의 단위

로우 단위로 데이터들이 저장되어 있음

칼럼수가 많다면 블럭에 저장되는 행의 수가 줄어듬

칼럼수가 적다면 블럭에 저장되는 행의 수가 늘어남



where 절과 order by 절에 자주 등장하는 칼럼을 인덱스로 설정

여러 칼럼을 조합해서 만들기도 함



인덱스의 단점

마구잡이로 생성하면 안된다

insert나 update는 속도가 느려짐

테이블에만 insert를 하는 것이 아니라 인덱스에도 insert를 해줘야 하기 때문에 인덱스가 많을수록 속도는 줄어든다.



인덱스 사용 불가한 경우

1. 인덱스 칼럼을 가공

수식이나 함수 등으로 인덱스 칼럼 절을 변형했을 경우

ex) 

```sql
select column_name from table_name where to_char(column_name, 'YYYYMMDD') = '20211119';

수정 => where column_name = to_date('20211119', 'YYYYMMDD');
```

반드시 함수나 수식을 사용해야 하는 경우면 인덱스 부분이 아닌 대입되는 칼럼이나 상수부분에 적용해야 한다. 



2. 인덱스 칼럼의 묵시적 형변환

서로 대입되는 항목끼리 데이터 타입이 다르면 내부적인 형 변환에 의해 칼럼이 함수를 사용한 효과를 나타냄

ex)

```sql
where column_name = '20211119';

수정 => where column_name = to_date('20211119', 'YYYYMMDD');
```



3. 부정형으로 조건을 사용한 경우

ex) 

```sql
select column_name from table_name where column_name != 30;

수정 => select column_name from table_name where column_name < 30 and column_name >30;
```



4. LIKE 연산자 사용 시 %가 앞에 위치

ex)

```sql
select column_name from table_name where column_name like '%S%';

수정 => select column_name from table_name where column_name like 'S%';
```



5. or 조건 사용 -> UNION ALL 대체

ex)

```sql
select column_name from table_name t1, table_name2 t2

where (t1.column_name1 = t2.column_name1 or t1.column_name2=t2.column_name2)

and t1.column_name3 = 'cmp_value';


수정 => select column_name from table_name t1, table_name2 t2

where t1.column_name1 = t2.column_name1 and t1.column_name3 = 'cmp_value';

UNION ALL

select column_name from table_name t1, table_name2 t2

where t1.column_name2 = t2.column_name2 and t1.column_name3 = 'cmp_value';
```



index range scan

index full scan

index skip scan

index fast full scan



인덱스를 탄다고 무조건 빨라지지는 않음, 손익분기점이 있다.  테이블이 가지고 있는 전체 데이터 양의 10에서 15프로 일때 효율적이고 그 이상일 떈 풀스캔이 더 빠르다. 







# :books:참고자료

https://www.youtube.com/watch?v=uO8tL0okg7Q 인덱스를 타면 왜 빨라지는지 아니? SQL전문가 정미나

https://isstory83.tistory.com/131

