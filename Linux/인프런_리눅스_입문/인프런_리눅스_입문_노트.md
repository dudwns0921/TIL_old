# 인프런_리눅스 입문 1강

### 리눅스 시작

1991년 리누스 토르발스

자신의 이름에다가 운영체제 이름인 unix를 붙여서 만듦

아직도 활발히 활동하는 리눅스 수장

### 리눅스 배포판

우분투 리눅스

센토스 리눅스

수세 리눅스

페도라 등등

리눅스의 종류가 많음

이러한 종류를 배포판이라고 부름

이 배포판들을 일컬어 리눅스라고 부름

서로 다른 목적으로 서로 다른 구성으로 만들어짐

Distrowatch 배포판들에 관련된 더 많은 정보를 알고 싶다면 방문해보기

### 공통점

리눅스 커널을 사용한다는 공통점

GNU 소프트웨어를 탑재하고 있음

### 차이점

데스크탑 관리자

패키지 매니저

기본 파일 시스템 등등

### 무엇을 선택해야할까?

사용자의 니즈에 맞춰서 배포판 중 골라서 설치하면 됨

가장 사람들이 많이 쓰는 건 우분투

# 2강 운영체제

컴퓨터의 하드웨어와 소프트웨어 자원을 관리하는 시스템 소프트웨어

블루스크린

운영체제에 오류가 나면 컴퓨터를 재부팅하기 전까지는 아무것도 할 수 없음

그만큼 중요한 부분

하드웨어와 소프트웨어 사이에서 이들이 잘 작동할 수 있도록 하는 시스템 소프트웨어

### 운영 체제 주요 구성요소

- #### 커널
  
  리눅스 배포판들의 공통점 리눅스 커널을 사용한다고 1강에서 말함
  
  커널은 가장 핵심적인 역할을 수행하는 부분
  
  하드웨어와 소프트웨어를 관리하는 곳
  
  가장 기본적이고 핵심적인 역할을 하는 소프트웨어
  
  여러 가지 소프트웨어를 동시에 실행할 수 있게 한다
  
  커널이 아래의 모든 것을 관리, 운영체제는 이 커널 플러스 알파라고 생각하면 됨

- #### 프로그램 실행과 멀티 테스킹

- #### 인터럽트

- #### 메모리 관리
  
  컴퓨터 구성요소
  
  CPU Memory HDD
  
  하드디스크에 소프트웨어가 저장되어있음
  
  이 소프트웨어를 읽어서 실행시키려면 먼저 메모리에 적재를 한다
  
  CPU가 메모리에 있는 코드를 가져다가 실행시키는 과정
  
  OS 입장에서는 시스템상의 메모리가 얼만큼 있고, 어디서부터 어디까지는 이미 사용중인지 정확하게 알아야 한다
  
  운영체제는 메모리의 상태를 맵으로 가지고 있다고 생각하자

- #### 파일 시스템
  
  저장 장치에 파일이라는 형태로 무언가를 저장
  
  수십, 수만개의 파일들이 저장가능
  
  파일 시스템은 저장 장치와 밀접한 관계가 있음
  
  저장 장치와 운영체제 중간에 위치해있다고 볼 수 있음
  
   컴퓨터에서 자료를 쉽게 발견하고 자료에 신속히 접근할 수 있도록 파일을 보관하거나 조직하는 체제.
  
  어디가 파일을 저장할 수 있는 빈 공간인지, 삭제를 통해 중간에 빈 공간이 생겼다면 그곳이 어디인지 파악해야 한다.

- #### 디바이스 드라이버
  
  일반적으로 운영체제와 같이 동작
  
  리눅스 커널과 같이 물려서 돌아감
  
  하나의 디바이스를 잘 작동시키기 위한 코드들이 있음

- #### 네트워킹

- #### 사용자 인터페이스

# 3강 패키지 관리 시스템

윈도우즈에 익숙하면 패키지 관리 시스템이 생소할 수 있음

스마트폰 쪽에서 더 많이 사용

구글플레이에서 게임 검색  후 설치

이 모든 것이 패키지 관리 시스템으로 구성

리눅스 배포판 종류마다 패키지 관리 시스템이 탑재되어 있음

파이썬같은 경우에는 pip

### 패키지 간 의존성

A패키지 B패키지

B가 있으려면 A가 필요하다 -> 의존성

이 부분때문에 굉장히 복잡해짐

소프트웨어가 의존성이 있어서 수많은 패키지가 필요하게 되면 말도 안 되는 복잡한 관계도가 그려질 수도 있다

패키지 관리 시스템은 이 관계를 모두 알고 있어야 한다.

그래서 사용자는 패키지 하나만 깔아줘라고 해도 수십 개의 패키지를 한꺼번에 설치할 수 있다.

패키지 -> 소프트웨어 배포를 위한 파일과 명령을 포함한 객체.

### 의존성이 생기는 이유?

라이브러리는 컴퓨터 프로그램에서 자주 사용되는 부분 프로그램들을 모아 놓은 것. 언제든지 자유롭게 이용할 수 있도록 구성되어 있다.

정적 라이브러리

실행 파일 하나가 라이브러리를 묶어서 가지고 있는 경우

동적 라이브러리

실행이 될 때 쉐어드 라이브러리를 찾아서 연결시켜줌

배포는 프로그램 하나로 배포가 되지만

프로그램을 시작하면 동적으로 라이브러리를 찾아서 한 덩어리처럼 작용

프로그램 X을 실행할 때 쉐어드 라이브러리가 필요하다면,

시스템에는 이미 쉐어드 라이브러리가 설치되어있어야 한다.

이부분에서 의존성이 발생

패키지 의존 관계가 생김

동적 라이브러리 사용되는 방식에 의해서 많은 것들이 의존 관계를 맺음

다른 이유에 의해서 의존 관계가 생길 수도 있음

복잡하게 얽혀있고, 이를 패키지 관리 시스템이 관리해준다

패키지 관리 시스템을 이용해서 리눅스에 어플리케이션을 설치하는 것을 권장

# 4강 가상화와 가상머신

10년 더 된 이야기

언젠가부터 가상화 기술 발전

일반 pc에서도 가상 머신들을 생성해서 하나의 pc에

윈도우즈 위에다가 리눅스 가상 머신을 설치해서 리눅스를 설치할 수 있게 되었다.

가상화

기존 가상화 기술이 발전하기 전에는 pc 위에 os 가 있고 그 위에 어플리케이션이 올라가는 구조

가상화 기술 도입

하나의 하드웨어 위에 가상화 레이어가 들어감

그 위에 os와 어플리케이션들이 여러 개 올라가게 됨

하나의 하드웨어 위에 여러 os가 올라가게 되는 것

가상화된 시스템에 올라가있는 가상화된 머신

pc에다가 처음에 리눅스를 먼저 설치를 하고 가상 머신으로 윈도우를 쓸 수 도 있음

가상머신 위에 올라가있는 os를 보통 게스트 os라고 함

기존에 있는 os는 호스트 os

호스트가 가상머신을 담고 있기 때문에 호스트의 그릇이 커야 함

### 리눅스 가상 머신 설치

- #### 호스트
  
  Dual core 이상의 CPU
  
  4gb 이상의 메모리

- #### 가상머신 관리자(둘 중에 하나 선택)
  
  VMWare Player
  
  Virualbox

- #### 리눅스 이미지(리눅스 설치파일 .iso, 둘 중에 선택)
  
  Ubuntu 20.04
  
  Centos 7.x

가상머신 관리자에 리눅스 이미지를 넣는다고 설정 후 부팅을 하면 가상의 DVD 장치로 인식을 해서 전원이 켜진다. vm에 연결된 iso 파일을 읽어서 리눅스 파일을 실행함

가상머신의 디스크가 호스트 디스크의 파일로서 존재 / 공간이 많이 남아있는 곳에다가 설치하는 것이 좋음

동적 할당

사용하는 양에 따라 조금씩 디스크의 양이 올라감

효율적

고정크기

처음부터 지정한 크기의 디스크의 용량을 사용

# 7강 리눅스 터미널

사용자가 시스템을 사용하기 위해서 shell로 접근

터미널을 통해 쉘의 사용

bash라고 하는 리눅스 쉘 프로그램을 터미널로 실행하는 것임

인터넷을 통해 리눅스 서버에 접속해서

가상머신에 접근 가능

과거에 쓰던 방법

telnet 

요즘은 ssh로 접속

클라우드 환경

리눅스를 더 많이 사용하고 있음

그래서 리눅스의 중요성이 강조되고 있음

GUI 반대 개념

CLI

comman line lnterface

리눅스에서 사용하는 많은 프로그램들이

CLI를 기반으로 하고 있음

GUI인 프로그램은 기능이 더 적음

# 8강 리눅스 기본 쉘 명령어

메뉴얼 조회 : man

파일 목록 / 내용 조회 관련 명령어 : ls, cat, head, tail

검색 / 탐색 관련 명령어 : grep, find

압축 / 해제 관련 명령어 : tar, gzip/gunzip, zip/unzip

시간 관련 명령어 : date, cal

기타 명령어 : echo, exit, history

관리자 권한 실행 : sudo

패키지 매니저 : apt

텍스트 에디터 : nano

bash 의 기본 명령어들도 있는데,

리눅스에 설치가 되어있어서 실행 가능한 명령어도 있다.

기본 명령어를 배운다고 하면 bash에서 사용할 수 있는 여러 가지 명령어들을 배운다고 보는 게 나음

하나의 명령어에 여러 가지 옵션이 있음

# 10강 디렉터리 내용 조회/이동/확인

리눅스는 트리 형태로 파일이 구성되어있음

루트 디렉터리는 /로 표현

모든 디렉토리는 루트 디렉토리 밑에 있음

/home => 루트 디렉토리 밑에 있는 home이라는 디렉토리

물결 의미

사용자의 홈디렉토리

jun@ubuntu:~$ cd ~
jun@ubuntu:~$ pwd
/home/jun

cd를 쳐도 홈 디렉토리로 돌아온다.

cd - 는 직전에 있었던 디렉토리로 이동

# 11강 파일 내용 조회

cat 파일 내용 전부를 다 보여주는 명령어

head 처음부터 일부만 보여줌(기본은 10줄)

tail 문서상의 끝에서 일부만 보여줌

head와 tail 모두 옵션으로 그 일부의 양을 정할 수 있음

옵션

head -n (원하는 줄 수) (파일명)

man과 비슷한 명령어로 --help가 있음

more

less

/키워드 입력하면 searching 기능

텍스트 편집기

vi

nano

윈도우즈에 익숙하다면 nano를 사용

emaes

shift+pageup 터미널에서 페이지 업

shift+pagedown 페이지 다운

명령어 이후 특정 파일 입력할 때, 파일명의 일부만 치고 tab을 누르면 자동으로 완성된다. 

# 12강 파일 내용 검색

1. grep "찾고 싶은 단어" 파일명

따옴표로 묶어주는 걸 쿼팅이라고 함

특정 키워드를 파일 내에서 검색할 때 사용하는 명령어

쿼팅을 안해주고 띄어쓰기가 포함된 키워드를 넣게 되면 파일명으로 인식하게 되어 원하는 결과를 얻지 못할 수도 있으니 주의하자

터미널에서 드래그를 하면 버퍼에 저장

클립보드에 저장되는 거랑 비슷

2. ls -al | grep kern.log

앞의 커맨드라인(출력)의 내용을 뒤(입력)에 보내준다고 생각

|을 기준으로 명령어가 나뉘어짐

ls -al의 결과중에서 kern.log를 찾아라는 뜻이 됨

이 두 가지 방법은 꼭 익혀두기

# 13강 파일 검색

내가 원하는 파일의 이름을 모를 경우

모든 위치에서 ls을 해서 찾을 수도 있겠지만 너무 번거로움

find

옵션

delete

print

exec COMMAND

exec

뒤의 명령어를 찾은 파일에 대해서 수행하라는 명령어

find를 잘 사용하면 굉장히 효과적으로 사용

delete 같은 경우는 조심해서 사용

검색 표현식을 잘못 사용하게 되면 엉뚱한 곳이 삭제될 수 있음

find --help

Usage: find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression]

기본 경로는 현재 디렉토리입니다; 기본 수식은 -print입니다

[]로 둘러싼 옵션은 생략가능하다는 의미

print 는 매치되는 파일을 출력하라는 의미

그래서 명령어를 따로 지정하지 않으면 설정한 디렉토리가 모두 출력

find

특정 디렉토리부터 그 하위에 있는 디렉토리를 모두 찾아라 명령이 됨

아무런 지정을 하지 않으면 현재 디렉토리를 기준으로 한다

이름으로 파일을 검색할 때

-name pattern

etc 밑에는 시스템 설정 파일이 들어있음

conf로 끝나면 대부분 설정파일

가장 많이 사용하는 건 파일 이름으로 찾는 것

find 경로 무엇을 조건

find /etc -name "*.conf" -print

.conf로 끝나는 모든 파일들을 찾아서 출력

find | grep "conf"

매커니즘상으로는 다르지만 결과는 같음

# 14강 압축 관련 커맨드

.zip

.gz

.tar.bz

.tar.gz

.tgz

등 리눅스에는 다양한 압축 파일 형식이 있음

find > (redirection이라고 함)

왼쪽에서 출력된 결과를 filelist라는 파일에다가 저장

file 명령어

해당 파일에 대한 정보를 줌

gzip 명령어

압축풀기

gunzip 명령어

압축풀기

리눅스에는 확장자라는 개념이 없음

리눅스는 확장자로 동작하지 않음

단지 그 파일의 종류를 알려주는 것뿐 / 이름일뿐

mv 파일명 바꿀 때 사용하는 명령어

tar 명령은 여러 파일들을 붙여서 하나로 만들어줌

단순히 붙이는 것뿐 압축은 되지 않는다.

그래서 tar.gz 이면

tar로 붙인 후에 gz로 압축했다는 의미이다.

  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.
  tar -tvf archive.tar         # List all files in archive.tar verbosely.
  tar -xf archive.tar          # Extract all files from archive.tar.

tar -czf 

압축까지 하라는 명령어

compress해라

gzip으로

-xzf

압축풀라는 명령어

# 15강 시간 및 기타 커맨드

date

날짜 출력

date -u 그리니치 천문대 시각

포매팅 기능

date +%Y

2021 연도만 출력됨

자주 사용하는 형태로 날짜 관련된 정보를 출력할 수 있음.

cal

현재 월이 포함된 달력을 보여줌

cal 2021

현재 연도 달력 한 번에 출력

cal -d 1995 -09

해당 년도 해당월 달력 출력

exit가 터미널 자체를 끝내는 명령어가 아니다

echo

메아리처럼 입력된 문자들을 그대로 다시 출력한다.

변수를 입력하면 해당 변수의 내용이 출력된다.

echo $PWD => 환경변수 , 이미 생성되어있는 변수

현재 위치

env 명령어

변수들에 어떤 값이 들어가 있는지 보여준다.

which

명령어의 경로를 확인하는 명령어

# 16강 관리자 권한 실행

리눅스에는 root라는 관리자 계정이 존재한다.

리눅스를 설치할 때 생성한 계정은 관리자 계정이 아니다.

해당 계정은 사용자 계정이기 때문에 권한이 제한되어있다.

관리자 계정으로만 수행 가능한 일들이 있다.

시스템의 중요한 설정을 바꾸는 등의 일

터미널에서 관리자 계정으로 실행해야 하는 명령어가 있을 때 사용하는 것이 sudo 명령어이다.

다른 계정으로 실행한 것처럼 실행한다는 의미이다.

sudo apt install ...

입력하면 암호를 입력하는 메시지가 뜬다.

이 때 필요한 건 사실 관리자 계정의 암호이지만, 첫 번째로 생성한 계정에게 sudo 명령어를 사용할 수 있는 권한이 주어진다.

# 17강 패키지 매니저 사용법

패키지 저장소에 대한 건 설치, 조회, 삭제 정도만 할 수 있으면 된다.

VM은 망가지면 삭제하고 다시 설치하면 되기 때문에 너무 망설이지 말고 팍팍 사용해보자

우분트 패키지 매니저 apt

apt 툴은 sudo를 입력해 관리자 권한으로 실행해야 한다.

install 명령어

이미 설치되어 있는 경우 최신 버전으로 업데이트를 해준다.

autoremove

하나의 패키지를 설치했을 때 연관되어 설치된 패키지들이 있는 경우, 그 패키지들이 삭제하는 패키지 외에 사용되는 경우가 없으면 모두 삭제한다.

apt list --installed

현재 설치된 패키지들을 보여준다.

뒤에 | grep 명령어를 사용해 본인이 찾고 싶은 패키지명을 찾아볼 수도 있다.

# 18강 나노 편집기 사용법

텍스트 편집기 : VIM, EMAX

텍스트 편집기인데 기능이 파워풀하다.

nano 좀 더 직관적인 텍스트 편집기

nano라고 치면 실행됨

컨트롤 O

해당 파일 이름 입력 후 저장

nano 파일 이름

nano 실행과 동시에 파일 열리며 

알트 6

텍스트 복사

컨트롤 U

붙여넣기

이후에 빔을 공부해보기

# 19강 파일과 디렉터리의 구조

파일의 가장 기본적인 속성인 이름

이 이름은 경로와 이름이 동시에 존재한다고 볼 수 있다.

같은 경로에 이름이 같은 파일이 2개 존재할 수는 없지만 다른 경로에는 존재할 수 있다.

파일 이름은 단순한 이름이 아닌 경로+이름의 구조로 다른 파일들과 구분된다고 볼 수 있다.

하나의 파일에는 데이터가 들어가 있다.

파일은 데이터를 담는 그릇과 같다.

변수도 마찬가지이다.

파일과 변수는 저장되는 위치가 다르다.

변수는 메모리, 파일은 디스크에 저장된다.

디스크의 형태는 다를 수 있다.

데이터를 영구적으로 저장하기 위해서 파일이라는 형태로 디스크에 저장한다.

여기서 영구적이라는 말은 전원이 없어도 지워지지 않는다 라는 의미로 받아들여야 한다.

메모리는 전원이 꺼지면 데이터가 모두 사라짐

운영체제는 하드웨어 위에 바로 올라가는 최초의 소프트웨어, 하드웨어 자원들을 관리하는 역할을 한다.

하드웨어에는 디스크도 포함됨

운영체제에는 파일에 관련된 여러 가지 행위들을 관리하는 하나의 계층이 존재한다.

이를 파일 시스템이라고 한다. 

파일 시스템은 운영체제와 디스크 사이에 존재한다고 생각하면 된다.

파일시스템(File system)이란 파일(자료)를 사용자가 쉽게 접근 및 발견 할 수 있도록 운영체제가 시스템의 디스크상에 일정한 규칙을 가지고 보관하는 방식

리눅스 운영체제의 경우에는 파티션을 나누고 정리하는데 주로 사용된다.

운영체제가 파일들을 일정한 규칙을 연속적으로 사용하여 디스크의 파티션상에 저장하게 되면

저장장치 내에서 파일 저장을 저장하는게 용이해지고 파일을 검색,관리를 효율적으로 할 수 있다.

리눅스는 대표적으로 ext3, ext4 iso9660, swap, nfs, xfs등의 파일 시스템을 사용하고 있다.

계층 구조

하나의 디렉토리에 모든 파일들이 저장된다면, 불편한 점들이 너무 많다.

이를 위해 의미 있는 구조를 만들어서 계층화 시킨 것이다. 

리눅스는 윈도우즈와는 달리 하나의 디렉토리부터 뻗어지는 싱글 디렉토리 트리 구조를 갖고 있다.

접근 가능한 모든 저장공간의 뿌리가 하나의 디렉토리와 연결된다는 의미이다.

윈도우의 경우는 드라이브당 각 하나의 디렉터리 트리 구조를 갖는다.(C드라이브, D드라이브...)

마운트란?

디스크란 물리적인 장치를 특정 위치, 즉 디렉터리에 연결시켜주는 것

윈도우즈에서는 자동으로 수행된다.

USB나 외장하드를 꼽으면 바로 폴더가 자동으로 생성되는 것을 확인할 수 있다.

리눅스에서는 직접 마운트 작업을 해줘야 한다.

# 20강 파일의 종류

| 파일의 종류     | 설명                                  |
| ---------- | ----------------------------------- |
| 일반 파일      | 말 그대로 일반 파일.<br />텍스트 파일이나 동영상 파일 등 |
| 디렉터리       | 디렉터리도 파일의 한 종류<br />윈도우의 폴더와 같은 개념  |
| 심볼릭 링크 파일  | 다른 파일을 가리키는 파일<br />윈도우의 바로가기       |
| 블록 디바이스 파일 | 블록 디바이스를 제어하기 위한 파일                 |
| 문자 디바이스 파일 | 문자 디바이스를 제어하기 위한 파일                 |
| 파이프 파일     | 파이프를 나타내는 파일<br />프로세스 간 통신에 사용됨    |
| 소켓         | 소켓을 나타내는 파일<br />프로세스 간 통신에 사용됨     |

하드웨어도 운영체제와 연결되어 있음

하드웨어를 관리할 수 있는 소프트웨어가 운영체제에 있음

이 소프트웨어의 이름이 디바이스 드라이버이다.

디바이스 드라이버가 하드웨어를 구동시켜준다.

디바이스 드라이버와 운영체제 협업

디바이스 드라이버는 애플리케이션과도 협업

이 때 필요한 것이 디바이스 파일이다.

운영체제 수준에 있는 디바이스 드라이버와 애플리케이션 사이의 통로를 만들어주는 것이 디바이스 파일이다.

디바이스 파일의 종류에는 블록 디바이스 파일, 문자 디바이스 파일이 있다.

키보드처럼 순차적인 동작에 대해서 처리를 할 때는 문자 디바이스 /

동작 방식에 따라 적합한 파일을 찾아서 사용

프로세스

구동중인 프로그램

프로세스와 프로세스가 통신을 하는 방식 => 파이프, 소켓

파이프나 소켓을 사용하면 해당 파일이 자동으로 생성됨

# 21강 대표적인 디렉터리

리눅스의 계층구조

루트 디렉터리 바로 밑에 있는 디렉터리들은 이름에 걸맞는 역할이 있다.

오랜 시간 동안 리눅스가 발전해오면서 어느 정도 관습화되었다.

| 디렉터리        | 설명                                |
| ----------- | --------------------------------- |
| /           | 루트 디렉터리, 모든 디렉터리의 최상위 부모          |
| /bin        | 모든 사용자가 사용할 수 있는 여러 가지 실행 파일 위치   |
| /sbin       | 시스템 관리자 권한으로 실행해야 하는 실행 파일 위치     |
| /etc        | 여러 가지 설정 파일(주의!)                  |
| /lib        | 공유 라이브러리 디렉터리                     |
| /home       | 사용자들의 홈 디렉터리                      |
| /mnt        | 일시적으로 파일 시스템에 마운트하는 경우 사용하는 디렉터리  |
| /proc, /sys | 시스템 정보를 설정 / 조회할 수 있는 디렉터리        |
| /tmp        | 임시 디렉터리                           |
| /usr        | 사용자가 추가한 실행 파일, 라이브러리 등의 소프트웨어 저장 |
| /dev        | 디바이스 드라이버가 사용하는 디바이스 파일 디렉터리      |

/bin

binary의 약자

시스템에 영향이 별로 없는 실행 파일들

/usr/bin

유저가 설치한 실행 파일

/etc

계정 아이디, 비밀번호

시스템의 설정들

etc 디렉터리 밑에 저장됨

일반 사용자 권한으로는 건들 수 없다

잘못 건드리면 시스템이 오작동할 수 있으니 주의

/mnt

usb나 cd-rom 같은 경우

/proc, /sys

실제로 하드디스크에 있는 디렉터리가 아님

OS가 만들어낸 가상의 디렉터리

운영체제의 정보를 보여주거나 설정할 수 있도록 애플리케이션과 운영체제 사이의 통로를 만들어준다.

/temp

임시 파일

/dev

OS가 만들어낸 가상의 디렉터리

# 22강 디렉터리

현재 작업 디렉터리(CWD : current working directory)

pwd 명령어

홈 디렉터리

/home/사용자 계정

리눅스는 멀티 유저를 지원하기 때문에

사용자가 여러 명이라는 걸 미리 가정한다.

상대경로 vs 절대경로

절대경로

/xyz/abc

/xyz/cde

상대경로 cwd를 기준으로 다른 디렉터리의 위치를 표시

/xyz/abc에 있을 때

../cde

.; 현재 디렉터리

..; 부모 디렉터리

# 23강 아이노드

하드링크와 소프트링크를 배우기 위한 개념

아이노드는 UFS(유닉스 파일 시스템)와 같은 전통적인 유닉스 계통 파일 시스템에서 사용하는 자료 구조이다.

파일 시스템 내에서 파일이나 디렉토리는 고유한 아이노드를 가지고 있으며 아이노드 번호를 통해 구분이 가능하다.

directory entry에는 파일 이름과 아이노드가 연결되어 있음

아이노드는 여러 가지 파일 데이터들과 연결되어 있음

Filename -- inode -- data

이렇게 연결되면 하나의 파일을 구성한다고 말할 수 있다.

아이노드는 파일의 여러 가지 데이터들을 저장해놓은 구조체이다.

소프트링크(=심볼릭링크=심링크)

윈도우즈 바로가기와 유사한 개념

Filename-symbolic link -- inode2 -- Link Data

소프트링크는 위와 같이 구성된다.

아이노드, 데이터가 대상 파일과 다르다.

소프트링크 파일의 링크 데이터에는 대상이 되는 파일의 경로가 포함된다.

하드링크

하드링크는 대상이 되는 파일의 아이노드를 공유한다.

아이노드에 연결된 파일 데이터도 공유되는 것이다.

파일 이름만 다르지 구성은 같다.

파일 시스템상에서는 쌍둥이처럼 취급

여러 개의 하드링크가 존재할 수 있지만, 하나의 파일만 존재한다.

# 24강 파일 다루기

ls 현재 디렉터리의 모든 파일들을 보여줌

ls -al 

숨겨진 파일들, 여러 가지 파일에 대한 정보를 확인 가능

디렉터리는 4096, 일반 파일들은 자신의 크기를 표시

파일 생성

빈 파일을 만드는 명령어

touch

파일 삭제 커맨드

rm

윈도우즈는 휴지통으로 이동시키고, 휴지통 비우기를 해야 완벽히 삭제되지만,

리눅스에서는 rm 명령어로 바로 완벽하게 삭제가 가능하다.

이름 바꾸기

mv

이름보다는 파일의 경로를 바꾸는 것

파일의 이름은 경로를 내포하고 있다.

mv apple /tmp/pineapple

apple이라는 파일을 tmp 아래 pineapple으로 이동

결국 tmp 아래 pineapple 이름으로 변경되어 저장

mv /tmp/pineapple .

이름을 변경하지 않고 현재 디렉터리로 가져오라는 의미

mv pineapple ../../tmp

상대경로로 tmp 디렉터리 아래로 이동

어떤 디렉터리든 . 과 .. 디렉터리를 무조건 갖고 있다.

.은 현재 디렉터리

.. 부모 디렉터리

# 25강 디렉터리 다루기

디렉터리도 파일의 한 종류

디렉터리를 만드는 명령어

mkdir newDir

디렉터리는 ls -al을 통해 나오는 정보들 중 가장 앞의 데이터가 d로 시작한다.(drwxr - xr - x)

cd newDir

작업 공간 이동

cd ..

부모 디렉터리로 이동

디렉터리 지우기

rmdir newDir

rmdir newDir/

같은 결과

삭제하려는 디렉터리 안에 다른 디렉터리나 파일이 존재하면 삭제 실패

기본적으로는 디렉터리 안의 모든 디렉터리나 파일들을 삭제해야 한다.

rm -r newDir(현재 newDir 안에 a라는 파일 존재)

디렉토리 삭제

rmdir 과 달리 파일이 들어있는 디렉터리도 삭제

-rf 강제로 지움

경고 없이 강제로 삭제

아주 위험한 명령어이기 때문에 주의 필요

디렉터리 이름 바꾸기

mv 명령어 사용, 디렉터리도 파일이기 때문에 파일에 mv 명령어를 썼던 것처럼 하면 된다.

# 26강 아이노드와 하드링크

ls -i

아이노드 넘버가 같이 출력됨

ls -ali

아이노드 넘버까지 포함된 파일들의 여러 가지 데이터를 출력

하드링크를 만드는 커맨드는 

ln

ln apple pineapple

apple이라는 파일의 하드링크를 pineapple이라는 이름으로 만듦

둘의 아이노드 넘버는 같다.

둘 중 어느 파일을 수정하든 결과는 동일하게 적용된다. 

stat 명령어

해당 파일에 대한 정보들

modify 는 파일의 콘텐츠 변경한 시각

change 아이노드가 변경된 시각

# 27강 소프트링크

소프트링크도 ln 명령어로 생성

-s 옵션을 붙여서 만든다.

ls -al

가장 먼저 나오는 정보

디렉터리는 d가 첫번째 문자

소프트링크는 l이 첫번째 문자

하드링크는 구분 문자가 없어서 주로 소프트링크를 많이 만든다.

성능적인 부분에서는 하드링크가 더 좋음

ls

어떤 파일에 링크되어있는지 확인은 할 수 없음

다만 텍스트 컬러가 다르기 때문에 소프트링크인 건 확인할 수 있다.

소프트링크에 cat 명령어를 사용하면 연결되어 있는 파일의 내용을 조회해서 알려준다.

대상 파일이 지워지면 소프트링크는 삭제는 되지 않지만 텍스트 컬러가 빨간색으로 변경된다. 

대상 파일이 지워진 후 같은 이름으로 다시 파일을 만들면 소프트링크는 해당 파일에 연결된다.

굉장히 타이트하게 연결되어있다기 보다는 그냥 그 경로만 저장되어 있다고 생각하면 된다.

하드링크는 경로가 변경되어도 아이노드는 그대로기 때문에 링크가 끊어지지 않는다.

소프트링크는 경로가 변경되면 링크가 끊어진다.

같은 디렉토리에 다시 같은 이름의 파일을 만들면 연결된다.

다른 경로에 있을 경우에는 파일 이름 대신 절대경로로 작성해준다.

# 29강 파일의 소유권과 권한

ls -al

첫 번째 컬럼

permission or mode

파일 접근 권한

d / rwx / rwx / rwx

1. file type(d는 디렉터리, - 일반 파일)
2. owner(user 권한 / read, write, execute)
3. group 권한
4. other users 권한

# 30강 파일 권한 표기법

chmod

change mod 파일의 권한을 변경해주는 툴

파일 권한은 8진수로 표기

2진수 3비트를 묶어 8진수로 변환

rwx

4 2 1 - 2진수 3비트

7 - 8진수

그래서 read, write, execute 권한이 owner, group, other users에 모두 부여되어있으면

파일 권한은 777이 된다.

의미 표기법

$ chmod [ugoa +/- rwx]<dir>

u = user

g = group

o = other users

a = all

`+` = add persmission

`-` = remove

8진 표기법은 한 번에 모든 권한을 수정할 수 있는 반면에

의미 표기법은 기존 권한에서 추가하거나 제외하는 방법이라서 기존 권한을 확실하게 알고 있지 않다면 자신이 원하는 결과가 나오지 않을 수도 있다. 

# 31강 /etc/passwd 파일 분석

각 계정에 대한 정보를 저장하고 설정하는 파일

모든 정보가 있는 건 아니다.

각각의 라인이 한 명의 유저와 그 설정

: 이 구분자로 각 필드를 구분하고 있다.

계정의 이름 : 계정의 암호 : UID(user id) : GID(group id) : description : 홈 디렉터리 : 기본 쉘

시스템상에서는 계정의 이름이 아닌 UID와 GID로 구분

root 계정은 UID 와 GID가 0

# 32강 사용자 추가 및 삭제

adduser, useradd 사용자 추가 명령어

adduser가 좀 더 사용하기가 편하다

adduser는 시스템 관리자 계정으로만 가능

sudo 명령어 필요

명령어 설명에서

[] 안에 있는 건 optional

[] 밖에 있는 건 필수

su

switch user

다른 사용자로 접속 가능

deluser 사용자 제거 명령어

# 33강 테스트 사용자 및 그룹 생성

그룹 추가

adduser --group

addgroup

특정 그룹에 유저 추가

adduser 유저이름 --ingroup 그룹이름

# 34강 파일 권한 실습

권한 변경

chmod 8진수 파일 이름

chmod g+w testfile

=> testfile 그룹에 쓰기 권한 추가

디렉터리에 쓰기 권한이 빠져있으면 새로운 파일을 추가할 수 없다.

# 35강 스크립트 실행

스크립트 파일 생성

첫 줄에 #!/bin/bash(어떤 스크립트 언어인지 표기)

파일 실행 방법

절대경로로 실행

파일명 일부를 치고 tab을 누르면 자동완성이 된다.

환경변수에 실행파일 추가

파일명만으로도 실행 가능

자주 쓰는 방법은 아님

상대경로 이용방법

# 36강 프로세스란?

프로세스는 사전 의미는 진행

시스템 상에서는 컴퓨터가 일을 하게 하는 주체

실행중인 프로그램을 뜻한다.

프로그램은 하드디스크에 저장되어 있는 실행 파일 자체

실행되면 프로세스, 프로세스는 메모리상에 있는 객체

code, stack, heap 과 같은 여러 가지 데이터들을 가지고 있음

CPU가 메모리상에 있는 프로세스를 실제로 실행

프로그램이 프로세스가 되는 순간 둘의 연결 관계는 끊어진다.

그 상태에서는 프로그램을 삭제할 수도 있다.

윈도우즈에서는 제약이 걸린다.

# 37강 프로세스 스케쥴링

여기서 스케줄링이란 **프로세스가 생성되어 실행될 때 필요한 시스템의 여러자원을 해당 프로세스에게 할당하는 작업**을 뜻 하며, **대기 시간은 최소화 하고 최대한 공평하게 처리하는 것을 목적**으로한다. 

메모리에 여러개의 프로세스를 올려놓고(=다중 프로그래밍), CPU의 가동시간을 적절히 나누어(=시분할) 각각의 프로세스에게 분배하여 실행되도록한다.

2000년대 초반, 한계치 이상까지 CPU의 클럭을 끌어올리던 CPU 제조회사들은 2002년에 3GHz(1초에 30억개의 전기 신호를 처리하는 속도) 클럭을 돌파하였다. 

문제는 거기서 발생하는 발열, 엄청난 전력소모. 클럭을 올리고 코어의 면적을 넓히는 방식으로 성능향상을 꾀하는 것은 점점 한계를 드러내고 있었다.

CPU의 성능이 매년마다 기하급수적으로 증가한다고 해도 코어 하나가 처리할 수 있는 작업 속도는 분명히 한계가 있기 때문이다.

물론, CPU 제조회사들도 당연히 이 부분을 알고 있었다. 문제는 당시 기술력으로는 더 이상의 발전이 불가능에 가까울만큼 어려웠고, 그래서 그들은 코어 하나를 극한으로 끌어올려서 성능 향상을 꾀하는 것 보다는 코어 수를 더 늘려서 좀 더 쉽게 CPU 전체의 성능 향상을 도모하는 쪽으로 발전하게 된 것이다.

# 38강 프로세스 상태

Created

Waiting

프로세스가 CPU를 기다리는 상태

프로세스가 메모리에 적재된 상태로 실행하는데 필요한 자원을 모두 얻은 상태

아직 CPU를 받지는 않았지만 CPU를 할당 받으면 바로 실행 가능한 상태

Running

프로세스가 CPU를 할당받아 명령어를 수행 중인 상태

일반적으로 CPU가 하나이기 때문에, 여러 프로세스가 동시에 실행되도 실제로 실행중인 프로세스는 매 시점 하나 뿐임

Blocked

프로세스가 CPU를 할당 받아도 당장 실행할 수 없는 상태

현재 프로세스가 I/O작업 등을 처리중인 상태를 의미

Terminated

프로세스의 실행 종료

프로세스의 실행이 완료되고 할당된 CPU를 반납

# 39강 프로세스 계층구조

## PID

프로세스 식별자

유닉스 커널과 같은 운영체제에서 각 프로세스나 서비스를 식별하기 위해 할당하는 고유한 번호

## 부모 프로세스와 자식 프로세스

한 프로세스는 실행되는 도중 프로세스 생성 시스템 콜을 통해 새로운 프로세스들을 생성할 수 있다.

다른 프로세스를 **생성하는 프로세스를 부모 프로세스(Parent Process)**라 하고, 다른 프로세스에 의해 **생성된 프로세스를 자식 프로세스(Child Process)**라 한다. 프로세스의 부모-자식 관계들은 트리의 형태로 나타나게 된다.

대부분의 운영체제에서는 프로세스들을 구별하기 위해 각 프로세스들에게 유일성을 가진 정수 **PID(Process Identifier)**를 부여한다.

## init 프로세스

부모 프로세스가 없다.

언제나 PID가 1번이다.

init 프로세스는 부팅 과정에서 커널에 의해 실행되고, 각종 서비스를 제공하는 다른 프로세스를 동작시키는 역할을 한다.

## 프로세스 종료 처리

자식 프로세스가 종료될때 부모 프로세스는 자식 프로세스를 정리해주는 작업을 한다. 

이를 프로세스 종료 처리라고 하고 이 처리가 제대로 이루어지지 않으면 고아 프로세스와 좀비 프로세스가 생긴다. 

## 고아 프로세스와 좀비 프로세스

위의 종료 처리가 제대로 이루어지지 않았을 때 발생하는 프로세스들이다.

고아 프로세스의 문제는 고아 프로세스가  종료되었을 때 그 종료 처리를 해줄 부모 프로세스가 없다.

리눅스는 고아 프로세스가 생기면 init으로 부모 프로세스를 바꿔준다. 

리눅스 상에서 init 프로세스는 종료되지 않는다.

자식 프로세스가 종료될 때 부모 프로세스는 자식 프로세스가 종료되었다는 신호를 받게 된다. 

그 신호를 받으면 부모 프로세스는 자식 프로세스를 정리한다.

혹은 자식 프로세스가 종료되길 기다렸다가 종료되는 순간 자식 프로세스를 정리한다.

위의 두 가지 방법대로 프로세스 종료 처리가 이루어지지 않으면 프로세스가 완벽하게 종료된 것이 아니기 때문에 리눅스 시스템 상에 남아있게 된다.

그렇게 되면 시스템 상 자원의 낭비가 생긴다. 

# 40강 프로세스 종료 상태

## 프로세스 종료 상태

프로세스가 종료될 때 넘겨주는 정보

부모 프로세스에게 정보를 넘기게 됨

부모 프로세스는 자식 프로세스가 종료될 때 자식 프로세스의 종료 처리를 해줘야 한다. 

종료 상태는 프로세스가 종료될 때 넘겨주는 정보

부모 프로세스가 자식 프로세스의 종료 처리를 하면서 그 정보를 읽어올 수 있다.

부모 프로세스는 자식 프로세스가 제대로 동작했는지 종료 상태를 통해 알 수 있다.

## 상태 정보

정상 종료 여부

시그널을 받아 종료되었는지 여부 및 시그널의 여부

코어 덤프를 생성했는지 여부

종료 상태에는 위의 정보들이 포함된다.

종료 상태값은 기본적으로 integer로 받게 된다.

0은 성공, 다른 값은 실패를 의미한다.

# 41강 표준 스트림

**표준 스트림**(standard streams)은 특정한 프로그래밍 언어 인터페이스뿐 아니라 유닉스 및 유닉스 계열 운영 체제(어느 정도까지는 윈도우에도 해당함)에서 컴퓨터 프로그램과 그 환경(일반적으로 단말기 사이에 미리 연결된 입출력 통로를 가리킨다.

일반적으로 유닉스에서 동작하는 프로그램은 실행 시 세 개의 스트림이 자동으로 열린다. 이를 표준 스트림이라고 부른다. 하나는 입력을 위한 스트림(Standard input, STDIN, 0), 하나는 출력을 위한 스트림(Standard Output, STDOUT, 1), 하나는 오류 메시지를 출력하기 위한 스트림(Standard Error, STDERR, 2)이며, 이 세 개의 표준 스트림은 사용자의 터미널에 부착된다.

보통 입출력은 물리적으로 연결된 시스템 콘솔의 키보드와 모니터를 통해 일어나는데, **표준 스트림**은 이것을 추상화한 것이다. 어떤 명령이 대화형 셸을 통해 실행될 때, 일반적으로 명령의 스트림은 셸이 실행중인 텍스트 터미널에 연결된다. 더 일반적으로 말하자면, **자식 프로세스는 부모 프로세스의 표준 스트림을 상속 받는다**고 할 수 있다.

## 파일 디스크립터

파일 디스크립터(File Descriptor)란 리눅스 혹은 유닉스 계열의 시스템에서 프로세스(process)가 파일(file)을 다룰 때 사용하는 개념으로, 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이다. **파일 디스크럽터는 일반적으로 0이 아닌 정수값을 갖는다.** 

흔히 유닉스 시스템에서 모든 것을 파일이라고 한다. 일반적인 정규파일부터 디렉토리, 소켓, 파이프, 블록 디바이스, 케릭터 디바이스 등 모든 객체들을 파일로 관리한다. 유닉스 시스템에서 프로세스가 이 파일들을 접근할 때 파일 디스크립터라는 개념을 이용한다. **프로세스가 실행 중에 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 숫자 중 사용하지 않는 가장 작은 값을 할당해준다. 그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.**

프로그램이 프로세스로 메모리에서 실행될 때, 기본적으로 할당되는 파일디스크립터는 표준입력(Standard Input), 표준 출력(Standard Output), 표준에러(Standard Error)이며 이들에게 각각 0, 1, 2라는 정수가 할당된다.

# 42강 포어그라운드 프로세스와 백그라운드 프로세스

## 포어그라운드 프로세스

쉘의 표준 입력이 연결된 프로세스

표준 출력과 표준 에러도 쉘과 연결되어 있음

일반적인 프로세스. 사용자와 상호작용하는 프로세스이다.

## 백그라운드 프로세스

쉘의 표준 입력이 연결되지 않은 프로세스

표준 출력과 표준 에러는 쉘과 연결되어 있음

백그라운드 프로세스는 사용자 간섭 없이 보이지 않는 뒷편에서 실행 중인 컴퓨터 프로세스

이러한 프로세스를 위한 일반적인 작업에는 로그 처리, 시스템 모니터링, 스케줄링, 사용자 통보 등이 있다.

# 43강 데몬 프로세스

악마 프로세스

MIT 대학의 프로그래머가 만든 용어

보이지 않는 곳에서 어떤 일을 하는 유령 에서 영감을 받음

데몬 프로세스

백그라운드 프로세스로 동작하기 위해 만들어진 프로세스

표준 스트림을 갖고 시작하지만 모두 닫아버림 -> 쉘과의 입출력 교환 불가

부모 프로세스를 init 프로세스로 변경

 일반적인 데몬은 터미널을 갖지 않는다. (**유저와 상호작용하지 않는다**.) 정확히는 데몬은 그 자체로 Process Group Leader로 부모가 1번 pid를 갖는 init으로 세팅된다. 즉, 독자적인 Session 을 갖고있으며 Linux System 자체가 아닌 별도의 독립된 Parent process를 갖지 않는다. 리눅스의 cron, smartd 와 같은 스케줄링 & 모니터링 프로세스들은 바로 이 Daemon Process 의 형태를 갖는다.

 백그라운드 프로세스는 이와 다르게 터미널을 통해 **상호작용이 가능**하다. 별도의 Parent process를 가질 수 있으며 Parent process와 세션이 공유되기 때문에 Parent process가 받는 Signal 의 영향을 받는다. (부모 프로세스가 종료되면 같이 종료된다.)

# 44강 시그널

시그널의 사전적인 뜻은 신호라는 의미로 리눅스에서는 프로세스끼리 서로 통신할 때 사용한다.

특정 프로세스가 다른 프로세스에게 메시지를 보낼 때 시그널을 이용한다.

리눅스에서 사용하는 시그널에는 사용자가 인터럽트 키를 통해 발생하는 시그널, 프로세스가 발생하는 시그널, 하드웨어가 발생하는 시그널 등 매우 다양하다. 

시그널 발생시 지정되어 있는 처리 방식은 크게 종료, 무시, 코어 덤프, 중단, 재시작 등이 있다.

코어 덤프는 프로세스가 비정상적으로 종료되었을 때 그 시점의 메모리 상태를 기록하는 걸 의미

디버깅할 때 코어 덤프를 통해 만들어진 코어 파일을 분석하게 된다.

주요 시그널

| 시그널 이름  | 의미                       | 기본처리 |
| ------- | ------------------------ | ---- |
| SIGINT  | 사용자가 인터럽트를 생성            | 종료   |
| SIGTERM | 프로세스 종료 명령(조건에 따른 처리 가능) | 종료   |
| SIGKILL | 프로세스 종료 명령(강제 종료)        | 종료   |
| SIGCHLD | 자식 프로세스 종료               | 무시   |

# 45강 프로세스 목록 조회 및 구조 파악

프로세스 명령어 ps

ps

옵션이 없을 경우 현재 터미널에서 실행된 프로세스만 보여줌

ps -f

풀 포맷으로 보여준다

여러 정보들을 같이 보여준다.

ps -e

커널 프로세스를 제외한 모든 프로세스 출력

ps -ef

전체 형식 목록으로 모든 실행 프로세스를 보여줌

ps -ef --forest

forest 형식에서 계층적 프로세스를 보여줌

```bash
jun         2045    1435  0 11:11 ?        00:00:02  \_ /usr/libexec/gnome-termi
jun         2056    2045  0 11:11 pts/0    00:00:00      \_ bash
jun         2237    2056  0 11:31 pts/0    00:00:00          \_ ps -ef --forest
```

ps -ef --forest 프로세스는 bash의 자식 프로세스

bash 프로세스는 gnome-termi의 자식 프로세스

UID
프로세스를 실행한 유저의 아이디

PID

프로세스의 식별번호

PPID

parent process ID

부모 프로세스 ID

C

짧은 시간 동안의 CPU 사용률

STIME

시작 시간

TTY

연결된 터미널을 의미

TIME

00:00:00

총 CPU 사용시간

CPU를 거의 사용하지 않았다는 의미

CMD

프로세스의 실행 명령행

bash에서 실행되는 명령어들은 모두 자식 프로세스로 실행이 된다.

vim 사용법

sudo apt install vim

vim 명령어로 실행

esc로 명령모드 진입

:q 명령어로 종료

:w test.txt 명령어로 저장

명령모드에서 입력모드로 전환

a 커서 위치 다음칸부터 입력

A 커서 행의 맨 마지막부터 입력

i 커서의 위치에 입력

I 커서 행의 맨 앞에서 부터 입력

o 커서의 다음행에 입력

O 커서의 이전 행에 입력

s 커서 위치의 한글자를 지우고 입력

cc 커서위치의 한 행을 지우고 입력

echo $$

현재 실행 중인 프로세스 PID 보여줌

```bash
#!/bin/bash

while[ 1 ]; do
        echo "hello, pid $$"
        sleep 3
done  
```

bash 스크립트임을 보여줌

# 46강 프로세스 종료 상태

```bash
jun@ubuntu:~$ ls /tmp
VMwareDnD
config-err-quw5Jw
ssh-MjwFFWJiWN8D
systemd-private-56b0d88a688e4e6e9157646ed3ff2e38-ModemManager.service-0VmQff
systemd-private-56b0d88a688e4e6e9157646ed3ff2e38-colord.service-vqDySi
systemd-private-56b0d88a688e4e6e9157646ed3ff2e38-switcheroo-control.service-NbJtfg
systemd-private-56b0d88a688e4e6e9157646ed3ff2e38-systemd-logind.service-rCwnwi
systemd-private-56b0d88a688e4e6e9157646ed3ff2e38-systemd-resolved.service-mY0j2f
systemd-private-56b0d88a688e4e6e9157646ed3ff2e38-systemd-timesyncd.service-JRh2Ih
systemd-private-56b0d88a688e4e6e9157646ed3ff2e38-upower.service-JFwkvj
tracker-extract-files.1000
tracker-extract-files.125
vmware-root_767-4256479648
jun@ubuntu:~$ echo $?
0
jun@ubuntu:~$ ls /fswfawefew
ls: '/fswfawefew'에 접근할 수 없습니다: 그런 파일이나 디렉터리가 없습니다
jun@ubuntu:~$ echo $?
2
```

echo $?

직전에 실행한 프로세스의 결과를 보여줌

ls /tmp는 성공적으로 실행되어 종료 상태값이 0으로 출력된다.

ls /... 은 해당 디렉터리가 존재하지 않아 실행에 실패했고, 종료 상태값이 2로 출력되었다.

# 48강 포어그라운드 프로세스와 백그라운드 프로세스

```bash
jun@ubuntu:~$ ./process.sh &

jun@ubuntu:~$ fg
```

위 명령어를 통해 포어그라운드 프로세스를 백그라운드 프로세스로 실행할 수 있다. 

fg 명령어를 실행시키면 다시 포어그라운드 프로세스로 실행된다. 

프로세스 실행 도중에 컨트롤 z를 누르면 프로세스가 멈춤이라는 텍스트와 함께 멈추게 된다.

이 때 fg, bg 명령어를 통해 포어그라운드 프로세스로 실행시킬지 백그라운드 프로세스로 실행시킬지 설정할 수 있다. 

jobs 명령어

현재 쉘에서 작업이 중지된 상태나 백그라운드로 진행 중인 상태 표시

l 옵션으로 PID, state를 함께 출력할 수 있다.

fg %2

퍼센트 뒤에 jobs에 나타나는 프로세스 넘버를 입력하면 해당 프로세스를 포어그라운드로 올릴 수 있다. 


