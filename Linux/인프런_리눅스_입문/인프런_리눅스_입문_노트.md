# 인프런_리눅스 입문 1강

### 리눅스 시작

1991년 리누스 토르발스

자신의 이름에다가 운영체제 이름인 unix를 붙여서 만듦

아직도 활발히 활동하는 리눅스 수장



### 리눅스 배포판

우분투 리눅스

센토스 리눅스

수세 리눅스

페도라 등등

리눅스의 종류가 많음

이러한 종류를 배포판이라고 부름

이 배포판들을 일컬어 리눅스라고 부름

서로 다른 목적으로 서로 다른 구성으로 만들어짐



Distrowatch 배포판들에 관련된 더 많은 정보를 알고 싶다면 방문해보기



### 공통점

리눅스 커널을 사용한다는 공통점

GNU 소프트웨어를 탑재하고 있음



### 차이점

데스크탑 관리자

패키지 매니저

기본 파일 시스템 등등



### 무엇을 선택해야할까?

사용자의 니즈에 맞춰서 배포판 중 골라서 설치하면 됨

가장 사람들이 많이 쓰는 건 우분투





# 2강 운영체제

컴퓨터의 하드웨어와 소프트웨어 자원을 관리하는 시스템 소프트웨어



블루스크린

운영체제에 오류가 나면 컴퓨터를 재부팅하기 전까지는 아무것도 할 수 없음

그만큼 중요한 부분

하드웨어와 소프트웨어 사이에서 이들이 잘 작동할 수 있도록 하는 시스템 소프트웨어



### 운영 체제 주요 구성요소

- #### 커널

  리눅스 배포판들의 공통점 리눅스 커널을 사용한다고 1강에서 말함

  커널은 가장 핵심적인 역할을 수행하는 부분

  하드웨어와 소프트웨어를 관리하는 곳

  가장 기본적이고 핵심적인 역할을 하는 소프트웨어

  여러 가지 소프트웨어를 동시에 실행할 수 있게 한다

  커널이 아래의 모든 것을 관리, 운영체제는 이 커널 플러스 알파라고 생각하면 됨

  

- #### 프로그램 실행과 멀티 테스킹

- #### 인터럽트

- #### 메모리 관리

  컴퓨터 구성요소

  CPU Memory HDD

  하드디스크에 소프트웨어가 저장되어있음

  이 소프트웨어를 읽어서 실행시키려면 먼저 메모리에 적재를 한다

  CPU가 메모리에 있는 코드를 가져다가 실행시키는 과정

  OS 입장에서는 시스템상의 메모리가 얼만큼 있고, 어디서부터 어디까지는 이미 사용중인지 정확하게 알아야 한다

  운영체제는 메모리의 상태를 맵으로 가지고 있다고 생각하자

  

- #### 파일 시스템

  저장 장치에 파일이라는 형태로 무언가를 저장

  수십, 수만개의 파일들이 저장가능

  파일 시스템은 저장 장치와 밀접한 관계가 있음

  저장 장치와 운영체제 중간에 위치해있다고 볼 수 있음

   컴퓨터에서 자료를 쉽게 발견하고 자료에 신속히 접근할 수 있도록 파일을 보관하거나 조직하는 체제.

  어디가 파일을 저장할 수 있는 빈 공간인지, 삭제를 통해 중간에 빈 공간이 생겼다면 그곳이 어디인지 파악해야 한다.

  

- #### 디바이스 드라이버

  일반적으로 운영체제와 같이 동작

  리눅스 커널과 같이 물려서 돌아감

  하나의 디바이스를 잘 작동시키기 위한 코드들이 있음

  

- #### 네트워킹

- #### 사용자 인터페이스



# 3강 패키지 관리 시스템

윈도우즈에 익숙하면 패키지 관리 시스템이 생소할 수 있음

스마트폰 쪽에서 더 많이 사용

구글플레이에서 게임 검색  후 설치

이 모든 것이 패키지 관리 시스템으로 구성



리눅스 배포판 종류마다 패키지 관리 시스템이 탑재되어 있음

파이썬같은 경우에는 pip



### 패키지 간 의존성

A패키지 B패키지

B가 있으려면 A가 필요하다 -> 의존성

이 부분때문에 굉장히 복잡해짐

소프트웨어가 의존성이 있어서 수많은 패키지가 필요하게 되면 말도 안 되는 복잡한 관계도가 그려질 수도 있다

패키지 관리 시스템은 이 관계를 모두 알고 있어야 한다.

그래서 사용자는 패키지 하나만 깔아줘라고 해도 수십 개의 패키지를 한꺼번에 설치할 수 있다.

패키지 -> 소프트웨어 배포를 위한 파일과 명령을 포함한 객체.



### 의존성이 생기는 이유?

라이브러리는 컴퓨터 프로그램에서 자주 사용되는 부분 프로그램들을 모아 놓은 것. 언제든지 자유롭게 이용할 수 있도록 구성되어 있다.

정적 라이브러리

실행 파일 하나가 라이브러리를 묶어서 가지고 있는 경우

동적 라이브러리

실행이 될 때 쉐어드 라이브러리를 찾아서 연결시켜줌

배포는 프로그램 하나로 배포가 되지만

프로그램을 시작하면 동적으로 라이브러리를 찾아서 한 덩어리처럼 작용



프로그램 X을 실행할 때 쉐어드 라이브러리가 필요하다면,

시스템에는 이미 쉐어드 라이브러리가 설치되어있어야 한다.

이부분에서 의존성이 발생



패키지 의존 관계가 생김

동적 라이브러리 사용되는 방식에 의해서 많은 것들이 의존 관계를 맺음

다른 이유에 의해서 의존 관계가 생길 수도 있음

복잡하게 얽혀있고, 이를 패키지 관리 시스템이 관리해준다

패키지 관리 시스템을 이용해서 리눅스에 어플리케이션을 설치하는 것을 권장



# 4강 가상화와 가상머신

10년 더 된 이야기

언젠가부터 가상화 기술 발전

일반 pc에서도 가상 머신들을 생성해서 하나의 pc에

윈도우즈 위에다가 리눅스 가상 머신을 설치해서 리눅스를 설치할 수 있게 되었다.



가상화

기존 가상화 기술이 발전하기 전에는 pc 위에 os 가 있고 그 위에 어플리케이션이 올라가는 구조



가상화 기술 도입

하나의 하드웨어 위에 가상화 레이어가 들어감

그 위에 os와 어플리케이션들이 여러 개 올라가게 됨

하나의 하드웨어 위에 여러 os가 올라가게 되는 것



가상화된 시스템에 올라가있는 가상화된 머신



pc에다가 처음에 리눅스를 먼저 설치를 하고 가상 머신으로 윈도우를 쓸 수 도 있음



가상머신 위에 올라가있는 os를 보통 게스트 os라고 함

기존에 있는 os는 호스트 os



호스트가 가상머신을 담고 있기 때문에 호스트의 그릇이 커야 함



### 리눅스 가상 머신 설치

- #### 호스트

  Dual core 이상의 CPU

  4gb 이상의 메모리

- #### 가상머신 관리자(둘 중에 하나 선택)

  VMWare Player

  Virualbox

- #### 리눅스 이미지(리눅스 설치파일 .iso, 둘 중에 선택)

  Ubuntu 20.04

  Centos 7.x



가상머신 관리자에 리눅스 이미지를 넣는다고 설정 후 부팅을 하면 가상의 DVD 장치로 인식을 해서 전원이 켜진다. vm에 연결된 iso 파일을 읽어서 리눅스 파일을 실행함



가상머신의 디스크가 호스트 디스크의 파일로서 존재 / 공간이 많이 남아있는 곳에다가 설치하는 것이 좋음



동적 할당

사용하는 양에 따라 조금씩 디스크의 양이 올라감

효율적



고정크기

처음부터 지정한 크기의 디스크의 용량을 사용



# 7강 리눅스 터미널

사용자가 시스템을 사용하기 위해서 shell로 접근

터미널을 통해 쉘의 사용

bash라고 하는 리눅스 쉘 프로그램을 터미널로 실행하는 것임



인터넷을 통해 리눅스 서버에 접속해서

가상머신에 접근 가능



과거에 쓰던 방법

telnet 



요즘은 ssh로 접속



클라우드 환경

리눅스를 더 많이 사용하고 있음

그래서 리눅스의 중요성이 강조되고 있음



GUI 반대 개념

CLI

comman line lnterface



리눅스에서 사용하는 많은 프로그램들이

CLI를 기반으로 하고 있음



GUI인 프로그램은 기능이 더 적음



# 8강 리눅스 기본 쉘 명령어

메뉴얼 조회 : man

파일 목록 / 내용 조회 관련 명령어 : ls, cat, head, tail

검색 / 탐색 관련 명령어 : grep, find

압축 / 해제 관련 명령어 : tar, gzip/gunzip, zip/unzip

시간 관련 명령어 : date, cal

기타 명령어 : echo, exit, history

관리자 권한 실행 : sudo

패키지 매니저 : apt

텍스트 에디터 : nano



bash 의 기본 명령어들도 있는데,

리눅스에 설치가 되어있어서 실행 가능한 명령어도 있다.

기본 명령어를 배운다고 하면 bash에서 사용할 수 있는 여러 가지 명령어들을 배운다고 보는 게 나음



하나의 명령어에 여러 가지 옵션이 있음



# 10강 디렉터리 내용 조회/이동/확인

리눅스는 트리 형태로 파일이 구성되어있음

루트 디렉터리는 /로 표현

모든 디렉토리는 루트 디렉토리 밑에 있음

/home => 루트 디렉토리 밑에 있는 home이라는 디렉토리



물결 의미

사용자의 홈디렉토리

jun@ubuntu:~$ cd ~
jun@ubuntu:~$ pwd
/home/jun

cd를 쳐도 홈 디렉토리로 돌아온다.

cd - 는 직전에 있었던 디렉토리로 이동



# 11강 파일 내용 조회

cat 파일 내용 전부를 다 보여주는 명령어

head 처음부터 일부만 보여줌(기본은 10줄)

tail 문서상의 끝에서 일부만 보여줌

head와 tail 모두 옵션으로 그 일부의 양을 정할 수 있음

옵션

head -n (원하는 줄 수) (파일명)



man과 비슷한 명령어로 --help가 있음



more

less

/키워드 입력하면 searching 기능



텍스트 편집기

vi

nano

윈도우즈에 익숙하다면 nano를 사용

emaes



shift+pageup 터미널에서 페이지 업

shift+pagedown 페이지 다운



명령어 이후 특정 파일 입력할 때, 파일명의 일부만 치고 tab을 누르면 자동으로 완성된다. 



# 12강 파일 내용 검색

1. grep "찾고 싶은 단어" 파일명

따옴표로 묶어주는 걸 쿼팅이라고 함

특정 키워드를 파일 내에서 검색할 때 사용하는 명령어

쿼팅을 안해주고 띄어쓰기가 포함된 키워드를 넣게 되면 파일명으로 인식하게 되어 원하는 결과를 얻지 못할 수도 있으니 주의하자





터미널에서 드래그를 하면 버퍼에 저장

클립보드에 저장되는 거랑 비슷



2. ls -al | grep kern.log

앞의 커맨드라인(출력)의 내용을 뒤(입력)에 보내준다고 생각

|을 기준으로 명령어가 나뉘어짐

ls -al의 결과중에서 kern.log를 찾아라는 뜻이 됨



이 두 가지 방법은 꼭 익혀두기



# 13강 파일 검색

내가 원하는 파일의 이름을 모를 경우

모든 위치에서 ls을 해서 찾을 수도 있겠지만 너무 번거로움

find



옵션

delete

print

exec COMMAND



exec

뒤의 명령어를 찾은 파일에 대해서 수행하라는 명령어



find를 잘 사용하면 굉장히 효과적으로 사용

delete 같은 경우는 조심해서 사용

검색 표현식을 잘못 사용하게 되면 엉뚱한 곳이 삭제될 수 있음



find --help

Usage: find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression]

기본 경로는 현재 디렉토리입니다; 기본 수식은 -print입니다



[]로 둘러싼 옵션은 생략가능하다는 의미

print 는 매치되는 파일을 출력하라는 의미

그래서 명령어를 따로 지정하지 않으면 설정한 디렉토리가 모두 출력



find

특정 디렉토리부터 그 하위에 있는 디렉토리를 모두 찾아라 명령이 됨

아무런 지정을 하지 않으면 현재 디렉토리를 기준으로 한다



이름으로 파일을 검색할 때

-name pattern



etc 밑에는 시스템 설정 파일이 들어있음

conf로 끝나면 대부분 설정파일



가장 많이 사용하는 건 파일 이름으로 찾는 것



find 경로 무엇을 조건

find /etc -name "*.conf" -print

.conf로 끝나는 모든 파일들을 찾아서 출력



find | grep "conf"

매커니즘상으로는 다르지만 결과는 같음



# 14강 압축 관련 커맨드



.zip

.gz

.tar.bz

.tar.gz



.tgz

등 리눅스에는 다양한 압축 파일 형식이 있음



find > (redirection이라고 함)

왼쪽에서 출력된 결과를 filelist라는 파일에다가 저장



file 명령어

해당 파일에 대한 정보를 줌



gzip 명령어

압축풀기



gunzip 명령어

압축풀기



리눅스에는 확장자라는 개념이 없음

리눅스는 확장자로 동작하지 않음

단지 그 파일의 종류를 알려주는 것뿐 / 이름일뿐



mv 파일명 바꿀 때 사용하는 명령어



tar 명령은 여러 파일들을 붙여서 하나로 만들어줌

단순히 붙이는 것뿐 압축은 되지 않는다.



그래서 tar.gz 이면

tar로 붙인 후에 gz로 압축했다는 의미이다.

  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.
  tar -tvf archive.tar         # List all files in archive.tar verbosely.
  tar -xf archive.tar          # Extract all files from archive.tar.



tar -czf 

압축까지 하라는 명령어

compress해라

gzip으로



-xzf

압축풀라는 명령어





# 15강 시간 및 기타 커맨드

date

날짜 출력



date -u 그리니치 천문대 시각



포매팅 기능

date +%Y

2021 연도만 출력됨

자주 사용하는 형태로 날짜 관련된 정보를 출력할 수 있음.



cal

현재 월이 포함된 달력을 보여줌

cal 2021

현재 연도 달력 한 번에 출력



cal -d 1995 -09

해당 년도 해당월 달력 출력



exit가 터미널 자체를 끝내는 명령어가 아니다



echo

메아리처럼 입력된 문자들을 그대로 다시 출력한다.



변수를 입력하면 해당 변수의 내용이 출력된다.

echo $PWD => 환경변수 , 이미 생성되어있는 변수

현재 위치



env 명령어

변수들에 어떤 값이 들어가 있는지 보여준다.



which

명령어의 경로를 확인하는 명령어



# 16강 관리자 권한 실행

리눅스에는 root라는 관리자 계정이 존재한다.



리눅스를 설치할 때 생성한 계정은 관리자 계정이 아니다.



해당 계정은 사용자 계정이기 때문에 권한이 제한되어있다.



관리자 계정으로만 수행 가능한 일들이 있다.



시스템의 중요한 설정을 바꾸는 등의 일



터미널에서 관리자 계정으로 실행해야 하는 명령어가 있을 때 사용하는 것이 sudo 명령어이다.



다른 계정으로 실행한 것처럼 실행한다는 의미이다.



sudo apt install ...

입력하면 암호를 입력하는 메시지가 뜬다.

이 때 필요한 건 사실 관리자 계정의 암호이지만, 첫 번째로 생성한 계정에게 sudo 명령어를 사용할 수 있는 권한이 주어진다.



# 17강 패키지 매니저 사용법

패키지 저장소에 대한 건 설치, 조회, 삭제 정도만 할 수 있으면 된다.

VM은 망가지면 삭제하고 다시 설치하면 되기 때문에 너무 망설이지 말고 팍팍 사용해보자



우분트 패키지 매니저 apt

apt 툴은 sudo를 입력해 관리자 권한으로 실행해야 한다.



install 명령어

이미 설치되어 있는 경우 최신 버전으로 업데이트를 해준다.



autoremove

하나의 패키지를 설치했을 때 연관되어 설치된 패키지들이 있는 경우, 그 패키지들이 삭제하는 패키지 외에 사용되는 경우가 없으면 모두 삭제한다.



apt list --installed

현재 설치된 패키지들을 보여준다.

뒤에 | grep 명령어를 사용해 본인이 찾고 싶은 패키지명을 찾아볼 수도 있다.



# 18강 나노 편집기 사용법

텍스트 편집기 : VIM, EMAX

텍스트 편집기인데 기능이 파워풀하다.



nano 좀 더 직관적인 텍스트 편집기

nano라고 치면 실행됨



컨트롤 O

해당 파일 이름 입력 후 저장



nano 파일 이름

nano 실행과 동시에 파일 열리며 



알트 6

텍스트 복사



컨트롤 U

붙여넣기



이후에 빔을 공부해보기



# 19강 파일과 디렉터리의 구조

파일의 가장 기본적인 속성인 이름

이 이름은 경로와 이름이 동시에 존재한다고 볼 수 있다.



같은 경로에 이름이 같은 파일이 2개 존재할 수는 없지만 다른 경로에는 존재할 수 있다.

파일 이름은 단순한 이름이 아닌 경로+이름의 구조로 다른 파일들과 구분된다고 볼 수 있다.



하나의 파일에는 데이터가 들어가 있다.

파일은 데이터를 담는 그릇과 같다.

변수도 마찬가지이다.



파일과 변수는 저장되는 위치가 다르다.

변수는 메모리, 파일은 디스크에 저장된다.

디스크의 형태는 다를 수 있다.



데이터를 영구적으로 저장하기 위해서 파일이라는 형태로 디스크에 저장한다.

여기서 영구적이라는 말은 전원이 없어도 지워지지 않는다 라는 의미로 받아들여야 한다.

메모리는 전원이 꺼지면 데이터가 모두 사라짐



운영체제는 하드웨어 위에 바로 올라가는 최초의 소프트웨어, 하드웨어 자원들을 관리하는 역할을 한다.

하드웨어에는 디스크도 포함됨



운영체제에는 파일에 관련된 여러 가지 행위들을 관리하는 하나의 계층이 존재한다.

이를 파일 시스템이라고 한다. 

파일 시스템은 운영체제와 디스크 사이에 존재한다고 생각하면 된다.



파일시스템(File system)이란 파일(자료)를 사용자가 쉽게 접근 및 발견 할 수 있도록 운영체제가 시스템의 디스크상에 일정한 규칙을 가지고 보관하는 방식

리눅스 운영체제의 경우에는 파티션을 나누고 정리하는데 주로 사용된다.

운영체제가 파일들을 일정한 규칙을 연속적으로 사용하여 디스크의 파티션상에 저장하게 되면

저장장치 내에서 파일 저장을 저장하는게 용이해지고 파일을 검색,관리를 효율적으로 할 수 있다.

리눅스는 대표적으로 ext3, ext4 iso9660, swap, nfs, xfs등의 파일 시스템을 사용하고 있다.



계층 구조

하나의 디렉토리에 모든 파일들이 저장된다면, 불편한 점들이 너무 많다.

이를 위해 의미 있는 구조를 만들어서 계층화 시킨 것이다. 



리눅스는 윈도우즈와는 달리 하나의 디렉토리부터 뻗어지는 싱글 디렉토리 트리 구조를 갖고 있다.

접근 가능한 모든 저장공간의 뿌리가 하나의 디렉토리와 연결된다는 의미이다.

윈도우의 경우는 드라이브당 각 하나의 디렉터리 트리 구조를 갖는다.(C드라이브, D드라이브...)



마운트란?

디스크란 물리적인 장치를 특정 위치, 즉 디렉터리에 연결시켜주는 것

윈도우즈에서는 자동으로 수행된다.

USB나 외장하드를 꼽으면 바로 폴더가 자동으로 생성되는 것을 확인할 수 있다.



리눅스에서는 직접 마운트 작업을 해줘야 한다.



# 20강 파일의 종류

| 파일의 종류        | 설명                                                     |
| ------------------ | -------------------------------------------------------- |
| 일반 파일          | 말 그대로 일반 파일.<br />텍스트 파일이나 동영상 파일 등 |
| 디렉터리           | 디렉터리도 파일의 한 종류<br />윈도우의 폴더와 같은 개념 |
| 심볼릭 링크 파일   | 다른 파일을 가리키는 파일<br />윈도우의 바로가기         |
| 블록 디바이스 파일 | 블록 디바이스를 제어하기 위한 파일                       |
| 문자 디바이스 파일 | 문자 디바이스를 제어하기 위한 파일                       |
| 파이프 파일        | 파이프를 나타내는 파일<br />프로세스 간 통신에 사용됨    |
| 소켓               | 소켓을 나타내는 파일<br />프로세스 간 통신에 사용됨      |



하드웨어도 운영체제와 연결되어 있음

하드웨어를 관리할 수 있는 소프트웨어가 운영체제에 있음

이 소프트웨어의 이름이 디바이스 드라이버이다.

디바이스 드라이버가 하드웨어를 구동시켜준다.



디바이스 드라이버와 운영체제 협업

디바이스 드라이버는 애플리케이션과도 협업

이 때 필요한 것이 디바이스 파일이다.



운영체제 수준에 있는 디바이스 드라이버와 애플리케이션 사이의 통로를 만들어주는 것이 디바이스 파일이다.

디바이스 파일의 종류에는 블록 디바이스 파일, 문자 디바이스 파일이 있다.

키보드처럼 순차적인 동작에 대해서 처리를 할 때는 문자 디바이스 /

동작 방식에 따라 적합한 파일을 찾아서 사용



프로세스

구동중인 프로그램

프로세스와 프로세스가 통신을 하는 방식 => 파이프, 소켓

파이프나 소켓을 사용하면 해당 파일이 자동으로 생성됨



# 21강 대표적인 디렉터리

리눅스의 계층구조

루트 디렉터리 바로 밑에 있는 디렉터리들은 이름에 걸맞는 역할이 있다.

오랜 시간 동안 리눅스가 발전해오면서 어느 정도 관습화되었다.



| 디렉터리    | 설명                                                       |
| ----------- | ---------------------------------------------------------- |
| /           | 루트 디렉터리, 모든 디렉터리의 최상위 부모                 |
| /bin        | 모든 사용자가 사용할 수 있는 여러 가지 실행 파일 위치      |
| /sbin       | 시스템 관리자 권한으로 실행해야 하는 실행 파일 위치        |
| /etc        | 여러 가지 설정 파일(주의!)                                 |
| /lib        | 공유 라이브러리 디렉터리                                   |
| /home       | 사용자들의 홈 디렉터리                                     |
| /mnt        | 일시적으로 파일 시스템에 마운트하는 경우 사용하는 디렉터리 |
| /proc, /sys | 시스템 정보를 설정 / 조회할 수 있는 디렉터리               |
| /tmp        | 임시 디렉터리                                              |
| /usr        | 사용자가 추가한 실행 파일, 라이브러리 등의 소프트웨어 저장 |
| /dev        | 디바이스 드라이버가 사용하는 디바이스 파일 디렉터리        |



/bin

binary의 약자

시스템에 영향이 별로 없는 실행 파일들



/usr/bin

유저가 설치한 실행 파일



/etc

계정 아이디, 비밀번호

시스템의 설정들

etc 디렉터리 밑에 저장됨



일반 사용자 권한으로는 건들 수 없다

잘못 건드리면 시스템이 오작동할 수 있으니 주의



/mnt

usb나 cd-rom 같은 경우



/proc, /sys

실제로 하드디스크에 있는 디렉터리가 아님

OS가 만들어낸 가상의 디렉터리

운영체제의 정보를 보여주거나 설정할 수 있도록 애플리케이션과 운영체제 사이의 통로를 만들어준다.



/temp

임시 파일



/dev

OS가 만들어낸 가상의 디렉터리



# 22강 디렉터리

현재 작업 디렉터리(CWD : current working directory)

pwd 명령어



홈 디렉터리

/home/사용자 계정

리눅스는 멀티 유저를 지원하기 때문에

사용자가 여러 명이라는 걸 미리 가정한다.



상대경로 vs 절대경로

절대경로

/xyz/abc

/xyz/cde

상대경로 cwd를 기준으로 다른 디렉터리의 위치를 표시

/xyz/abc에 있을 때

../cde

.; 현재 디렉터리

..; 부모 디렉터리



# 23강 아이노드

하드링크와 소프트링크를 배우기 위한 개념

아이노드는 UFS(유닉스 파일 시스템)와 같은 전통적인 유닉스 계통 파일 시스템에서 사용하는 자료 구조이다.

파일 시스템 내에서 파일이나 디렉토리는 고유한 아이노드를 가지고 있으며 아이노드 번호를 통해 구분이 가능하다.



directory entry에는 파일 이름과 아이노드가 연결되어 있음

아이노드는 여러 가지 파일 데이터들과 연결되어 있음



Filename -- inode -- data

이렇게 연결되면 하나의 파일을 구성한다고 말할 수 있다.



아이노드는 파일의 여러 가지 데이터들을 저장해놓은 구조체이다.



소프트링크(=심볼릭링크=심링크)

윈도우즈 바로가기와 유사한 개념



Filename-symbolic link -- inode2 -- Link Data

소프트링크는 위와 같이 구성된다.

아이노드, 데이터가 대상 파일과 다르다.

소프트링크 파일의 링크 데이터에는 대상이 되는 파일의 경로가 포함된다.



하드링크

하드링크는 대상이 되는 파일의 아이노드를 공유한다.

아이노드에 연결된 파일 데이터도 공유되는 것이다.

파일 이름만 다르지 구성은 같다.

파일 시스템상에서는 쌍둥이처럼 취급

여러 개의 하드링크가 존재할 수 있지만, 하나의 파일만 존재한다.



# 24강 파일 다루기

ls 현재 디렉터리의 모든 파일들을 보여줌

ls -al 

숨겨진 파일들, 여러 가지 파일에 대한 정보를 확인 가능

디렉터리는 4096, 일반 파일들은 자신의 크기를 표시



파일 생성

빈 파일을 만드는 명령어

touch



파일 삭제 커맨드

rm

윈도우즈는 휴지통으로 이동시키고, 휴지통 비우기를 해야 완벽히 삭제되지만,

리눅스에서는 rm 명령어로 바로 완벽하게 삭제가 가능하다.



이름 바꾸기

mv

이름보다는 파일의 경로를 바꾸는 것

파일의 이름은 경로를 내포하고 있다.



mv apple /tmp/pineapple

apple이라는 파일을 tmp 아래 pineapple으로 이동

결국 tmp 아래 pineapple 이름으로 변경되어 저장



mv /tmp/pineapple .

이름을 변경하지 않고 현재 디렉터리로 가져오라는 의미



mv pineapple ../../tmp

상대경로로 tmp 디렉터리 아래로 이동



어떤 디렉터리든 . 과 .. 디렉터리를 무조건 갖고 있다.

.은 현재 디렉터리

.. 부모 디렉터리



# 25강 디렉터리 다루기

디렉터리도 파일의 한 종류



디렉터리를 만드는 명령어

mkdir newDir



디렉터리는 ls -al을 통해 나오는 정보들 중 가장 앞의 데이터가 d로 시작한다.(drwxr - xr - x)



cd newDir

작업 공간 이동

cd ..

부모 디렉터리로 이동



디렉터리 지우기

rmdir newDir

rmdir newDir/

같은 결과

삭제하려는 디렉터리 안에 다른 디렉터리나 파일이 존재하면 삭제 실패

기본적으로는 디렉터리 안의 모든 디렉터리나 파일들을 삭제해야 한다.



rm -r newDir(현재 newDir 안에 a라는 파일 존재)

디렉토리 삭제

rmdir 과 달리 파일이 들어있는 디렉터리도 삭제



-rf 강제로 지움

경고 없이 강제로 삭제

아주 위험한 명령어이기 때문에 주의 필요



디렉터리 이름 바꾸기

mv 명령어 사용, 디렉터리도 파일이기 때문에 파일에 mv 명령어를 썼던 것처럼 하면 된다.



# 26강 아이노드와 하드링크

ls -i

아이노드 넘버가 같이 출력됨



ls -ali

아이노드 넘버까지 포함된 파일들의 여러 가지 데이터를 출력



하드링크를 만드는 커맨드는 

ln



ln apple pineapple

apple이라는 파일의 하드링크를 pineapple이라는 이름으로 만듦



둘의 아이노드 넘버는 같다.



둘 중 어느 파일을 수정하든 결과는 동일하게 적용된다. 



stat 명령어

해당 파일에 대한 정보들

modify 는 파일의 콘텐츠 변경한 시각

change 아이노드가 변경된 시각



# 27강 소프트링크

소프트링크도 ln 명령어로 생성

-s 옵션을 붙여서 만든다.



ls -al

가장 먼저 나오는 정보

디렉터리는 d가 첫번째 문자

소프트링크는 l이 첫번째 문자

하드링크는 구분 문자가 없어서 주로 소프트링크를 많이 만든다.



성능적인 부분에서는 하드링크가 더 좋음



ls

어떤 파일에 링크되어있는지 확인은 할 수 없음

다만 텍스트 컬러가 다르기 때문에 소프트링크인 건 확인할 수 있다.



소프트링크에 cat 명령어를 사용하면 연결되어 있는 파일의 내용을 조회해서 알려준다.



대상 파일이 지워지면 소프트링크는 삭제는 되지 않지만 텍스트 컬러가 빨간색으로 변경된다. 

대상 파일이 지워진 후 같은 이름으로 다시 파일을 만들면 소프트링크는 해당 파일에 연결된다.

굉장히 타이트하게 연결되어있다기 보다는 그냥 그 경로만 저장되어 있다고 생각하면 된다.



하드링크는 경로가 변경되어도 아이노드는 그대로기 때문에 링크가 끊어지지 않는다.

소프트링크는 경로가 변경되면 링크가 끊어진다.

같은 디렉토리에 다시 같은 이름의 파일을 만들면 연결된다.



다른 경로에 있을 경우에는 파일 이름 대신 절대경로로 작성해준다.



# 29강 파일의 소유권과 권한



ls -al

첫 번째 컬럼

permission or mode

파일 접근 권한

d / rwx / rwx / rwx

1. file type(d는 디렉터리, - 일반 파일)
2. owner(user 권한 / read, write, execute)
3. group 권한
4. other users 권한





# 30강 파일 권한 표기법

chmod

change mod 파일의 권한을 변경해주는 툴



파일 권한은 8진수로 표기

2진수 3비트를 묶어 8진수로 변환



rwx

4 2 1 - 2진수 3비트

7 - 8진수



그래서 read, write, execute 권한이 owner, group, other users에 모두 부여되어있으면

파일 권한은 777이 된다.



의미 표기법

$ chmod [ugoa +/- rwx]<dir>



u = user

g = group

o = other users

a = all

`+` = add persmission

`-` = remove



8진 표기법은 한 번에 모든 권한을 수정할 수 있는 반면에

의미 표기법은 기존 권한에서 추가하거나 제외하는 방법이라서 기존 권한을 확실하게 알고 있지 않다면 자신이 원하는 결과가 나오지 않을 수도 있다. 



# 31강 /etc/passwd 파일 분석

각 계정에 대한 정보를 저장하고 설정하는 파일

모든 정보가 있는 건 아니다.

각각의 라인이 한 명의 유저와 그 설정

: 이 구분자로 각 필드를 구분하고 있다.

계정의 이름 : 계정의 암호 : UID(user id) : GID(group id) : description : 홈 디렉터리 : 기본 쉘

시스템상에서는 계정의 이름이 아닌 UID와 GID로 구분



root 계정은 UID 와 GID가 0



# 32강 사용자 추가 및 삭제

adduser, useradd 사용자 추가 명령어

adduser가 좀 더 사용하기가 편하다



adduser는 시스템 관리자 계정으로만 가능

sudo 명령어 필요



명령어 설명에서

[] 안에 있는 건 optional

[] 밖에 있는 건 필수



su

switch user

다른 사용자로 접속 가능



deluser 사용자 제거 명령어



























































































